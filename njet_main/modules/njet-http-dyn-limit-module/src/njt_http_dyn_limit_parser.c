

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_http_dyn_limit_parser.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */

static bool parse_dyn_limit_locationDef(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_t *out, js2c_parse_error_t *err_ret); //forward decl for public definition
static void get_json_length_dyn_limit_locationDef(njt_pool_t *pool, dyn_limit_locationDef_t *out, size_t *length, njt_int_t flags); //forward decl for public definition
static void to_oneline_json_dyn_limit_locationDef(njt_pool_t *pool, dyn_limit_locationDef_t *out, njt_str_t *buf, njt_int_t flags); //forward decl for public definition

static bool parse_dyn_limit_locationDef_limit_conns_scope(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_conns_scope_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "up_share")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_UP_SHARE;
    } else if (current_string_is(parse_state, "location")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_LOCATION;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_conns_item(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_conns_item_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "zone")) {
            js2c_check_field_set(out->is_zone_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "zone";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->zone))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->zone))->data);
            ((&out->zone))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->zone), 0, ((&out->zone))->len, err_ret)) {
                return true;
            }
            out->is_zone_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "conn")) {
            js2c_check_field_set(out->is_conn_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "conn";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->conn) = int_parse_tmp;
            out->is_conn_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_zone_set) {
        size_t token_size = strlen("");
        (out->zone).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->zone).data);
        (out->zone).len = token_size;
        if (out->zone.len == 0) {
            (out->zone).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->zone.data, "", token_size);
        }
    }
    // set default
    if (!out->is_conn_set) {
        out->conn = 0LL;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_conns(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_conns_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_limit_conns_item_t));
        memset(((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i], 0, sizeof(dyn_limit_locationDef_limit_conns_item_t));
        if (parse_dyn_limit_locationDef_limit_conns_item(pool, parse_state, ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_locationDef_limit_conn_dry_run(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_conn_dry_run_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "on")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_ON;
    } else if (current_string_is(parse_state, "off")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_OFF;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_conn_log_level(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_conn_log_level_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "info")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_INFO;
    } else if (current_string_is(parse_state, "notice")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_NOTICE;
    } else if (current_string_is(parse_state, "warn")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_WARN;
    } else if (current_string_is(parse_state, "error")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_ERROR;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_reqs_scope(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_reqs_scope_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "up_share")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_UP_SHARE;
    } else if (current_string_is(parse_state, "location")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_LOCATION;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_reqs_item(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_reqs_item_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "zone")) {
            js2c_check_field_set(out->is_zone_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "zone";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->zone))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->zone))->data);
            ((&out->zone))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->zone), 0, ((&out->zone))->len, err_ret)) {
                return true;
            }
            out->is_zone_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "burst")) {
            js2c_check_field_set(out->is_burst_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "burst";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->burst) = int_parse_tmp;
            out->is_burst_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "delay")) {
            js2c_check_field_set(out->is_delay_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "delay";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->delay))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->delay))->data);
            ((&out->delay))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->delay), 0, ((&out->delay))->len, err_ret)) {
                return true;
            }
            out->is_delay_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_zone_set) {
        size_t token_size = strlen("");
        (out->zone).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->zone).data);
        (out->zone).len = token_size;
        if (out->zone.len == 0) {
            (out->zone).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->zone.data, "", token_size);
        }
    }
    // set default
    if (!out->is_burst_set) {
        out->burst = 0LL;
    }
    // set default
    if (!out->is_delay_set) {
        size_t token_size = strlen("");
        (out->delay).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->delay).data);
        (out->delay).len = token_size;
        if (out->delay.len == 0) {
            (out->delay).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->delay.data, "", token_size);
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_reqs(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_reqs_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_limit_reqs_item_t));
        memset(((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i], 0, sizeof(dyn_limit_locationDef_limit_reqs_item_t));
        if (parse_dyn_limit_locationDef_limit_reqs_item(pool, parse_state, ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_locationDef_limit_req_dry_run(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_req_dry_run_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "on")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_ON;
    } else if (current_string_is(parse_state, "off")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_OFF;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_limit_req_log_level(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_limit_req_log_level_t *out, js2c_parse_error_t *err_ret) {
    js2c_check_type(JSMN_STRING);
    if (current_string_is(parse_state, "info")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_INFO;
    } else if (current_string_is(parse_state, "notice")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_NOTICE;
    } else if (current_string_is(parse_state, "warn")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_WARN;
    } else if (current_string_is(parse_state, "error")) {
        *out = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_ERROR;
    } else {
        LOG_ERROR_JSON_PARSE(UNKNOWN_ENUM_VALUE_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_dyn_limit_locationDef_locations(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_locations_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_locationDef_locations_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_t));
        memset(((dyn_limit_locationDef_locations_item_t**)out->elts)[i], 0, sizeof(dyn_limit_locationDef_locations_item_t));
        if (parse_dyn_limit_locationDef(pool, parse_state, ((dyn_limit_locationDef_locations_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_locationDef(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_locationDef_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "location")) {
            js2c_check_field_set(out->is_location_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "location";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->location))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->location))->data);
            ((&out->location))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->location), 0, ((&out->location))->len, err_ret)) {
                return true;
            }
            out->is_location_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_rate")) {
            js2c_check_field_set(out->is_limit_rate_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_rate";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->limit_rate))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->limit_rate))->data);
            ((&out->limit_rate))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->limit_rate), 0, ((&out->limit_rate))->len, err_ret)) {
                return true;
            }
            out->is_limit_rate_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_rate_after")) {
            js2c_check_field_set(out->is_limit_rate_after_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_rate_after";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->limit_rate_after))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->limit_rate_after))->data);
            ((&out->limit_rate_after))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->limit_rate_after), 0, ((&out->limit_rate_after))->len, err_ret)) {
                return true;
            }
            out->is_limit_rate_after_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_conns_scope")) {
            js2c_check_field_set(out->is_limit_conns_scope_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_conns_scope";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_conns_scope(pool, parse_state, (&out->limit_conns_scope), err_ret)) {
                return true;
            }
            out->is_limit_conns_scope_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_conns")) {
            js2c_check_field_set(out->is_limit_conns_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_conns";
            js2c_null_check();
            out->limit_conns = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_locationDef_limit_conns_item_t*));
            js2c_malloc_check(out->limit_conns);

            if (parse_dyn_limit_locationDef_limit_conns(pool, parse_state, (out->limit_conns), err_ret)) {
                return true;
            }
            out->is_limit_conns_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_conn_dry_run")) {
            js2c_check_field_set(out->is_limit_conn_dry_run_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_conn_dry_run";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_conn_dry_run(pool, parse_state, (&out->limit_conn_dry_run), err_ret)) {
                return true;
            }
            out->is_limit_conn_dry_run_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_conn_log_level")) {
            js2c_check_field_set(out->is_limit_conn_log_level_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_conn_log_level";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_conn_log_level(pool, parse_state, (&out->limit_conn_log_level), err_ret)) {
                return true;
            }
            out->is_limit_conn_log_level_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_conn_status")) {
            js2c_check_field_set(out->is_limit_conn_status_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_conn_status";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(400LL);
            js2c_int_range_check_max(599LL);
            *(&out->limit_conn_status) = int_parse_tmp;
            out->is_limit_conn_status_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_reqs_scope")) {
            js2c_check_field_set(out->is_limit_reqs_scope_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_reqs_scope";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_reqs_scope(pool, parse_state, (&out->limit_reqs_scope), err_ret)) {
                return true;
            }
            out->is_limit_reqs_scope_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_reqs")) {
            js2c_check_field_set(out->is_limit_reqs_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_reqs";
            js2c_null_check();
            out->limit_reqs = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_locationDef_limit_reqs_item_t*));
            js2c_malloc_check(out->limit_reqs);

            if (parse_dyn_limit_locationDef_limit_reqs(pool, parse_state, (out->limit_reqs), err_ret)) {
                return true;
            }
            out->is_limit_reqs_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_req_dry_run")) {
            js2c_check_field_set(out->is_limit_req_dry_run_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_req_dry_run";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_req_dry_run(pool, parse_state, (&out->limit_req_dry_run), err_ret)) {
                return true;
            }
            out->is_limit_req_dry_run_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_req_log_level")) {
            js2c_check_field_set(out->is_limit_req_log_level_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_req_log_level";
            js2c_null_check();
            if (parse_dyn_limit_locationDef_limit_req_log_level(pool, parse_state, (&out->limit_req_log_level), err_ret)) {
                return true;
            }
            out->is_limit_req_log_level_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_req_status")) {
            js2c_check_field_set(out->is_limit_req_status_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_req_status";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(400LL);
            js2c_int_range_check_max(599LL);
            *(&out->limit_req_status) = int_parse_tmp;
            out->is_limit_req_status_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "locations")) {
            js2c_check_field_set(out->is_locations_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "locations";
            js2c_null_check();
            out->locations = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_locationDef_locations_item_t*));
            js2c_malloc_check(out->locations);

            if (parse_dyn_limit_locationDef_locations(pool, parse_state, (out->locations), err_ret)) {
                return true;
            }
            out->is_locations_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_location_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': location", parse_state->current_key);
        return true;
    }
    // set default
    if (!out->is_limit_rate_set) {
        size_t token_size = strlen("");
        (out->limit_rate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->limit_rate).data);
        (out->limit_rate).len = token_size;
        if (out->limit_rate.len == 0) {
            (out->limit_rate).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->limit_rate.data, "", token_size);
        }
    }
    // set default
    if (!out->is_limit_rate_after_set) {
        size_t token_size = strlen("");
        (out->limit_rate_after).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->limit_rate_after).data);
        (out->limit_rate_after).len = token_size;
        if (out->limit_rate_after.len == 0) {
            (out->limit_rate_after).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->limit_rate_after.data, "", token_size);
        }
    }
    // set default
    if (!out->is_limit_conns_scope_set) {
        out->limit_conns_scope = DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_UP_SHARE;
    }
    // set default
    if (!out->is_limit_conns_set) {
        out->limit_conns = njt_pcalloc(pool, sizeof(njt_array_t));
    }
    // set default
    if (!out->is_limit_conn_dry_run_set) {
        out->limit_conn_dry_run = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_OFF;
    }
    // set default
    if (!out->is_limit_conn_log_level_set) {
        out->limit_conn_log_level = DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_WARN;
    }
    // set default
    if (!out->is_limit_conn_status_set) {
        out->limit_conn_status = 400LL;
    }
    // set default
    if (!out->is_limit_reqs_scope_set) {
        out->limit_reqs_scope = DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_UP_SHARE;
    }
    // set default
    if (!out->is_limit_reqs_set) {
        out->limit_reqs = njt_pcalloc(pool, sizeof(njt_array_t));
    }
    // set default
    if (!out->is_limit_req_dry_run_set) {
        out->limit_req_dry_run = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_OFF;
    }
    // set default
    if (!out->is_limit_req_log_level_set) {
        out->limit_req_log_level = DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_WARN;
    }
    // set default
    if (!out->is_limit_req_status_set) {
        out->limit_req_status = 400LL;
    }
    // set default
    if (!out->is_locations_set) {
        out->locations = njt_pcalloc(pool, sizeof(njt_array_t));
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_dyn_limit_locationDef_location(njt_pool_t *pool, dyn_limit_locationDef_location_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_locationDef_limit_rate(njt_pool_t *pool, dyn_limit_locationDef_limit_rate_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_locationDef_limit_rate_after(njt_pool_t *pool, dyn_limit_locationDef_limit_rate_after_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_conns_scope(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_scope_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_UP_SHARE) {
        // "up_share"
        *length += 8 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_LOCATION) {
        // "location"
        *length += 8 + 2;
        return;
    }
}

static void get_json_length_dyn_limit_locationDef_limit_conns_item_zone(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_zone_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_locationDef_limit_conns_item_conn(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_conn_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_dyn_limit_locationDef_limit_conns_item(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "zone": 
        get_json_length_dyn_limit_locationDef_limit_conns_item_zone(pool, (&out->zone), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_conn_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "conn": 
        get_json_length_dyn_limit_locationDef_limit_conns_item_conn(pool, (&out->conn), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_dyn_limit_locationDef_limit_conns(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_locationDef_limit_conns_item(pool, ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_conn_dry_run(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_dry_run_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_ON) {
        // "on"
        *length += 2 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_OFF) {
        // "off"
        *length += 3 + 2;
        return;
    }
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_conn_log_level(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_log_level_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_INFO) {
        // "info"
        *length += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_NOTICE) {
        // "notice"
        *length += 6 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_WARN) {
        // "warn"
        *length += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_ERROR) {
        // "error"
        *length += 5 + 2;
        return;
    }
}

static void get_json_length_dyn_limit_locationDef_limit_conn_status(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_status_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_reqs_scope(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_scope_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_UP_SHARE) {
        // "up_share"
        *length += 8 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_LOCATION) {
        // "location"
        *length += 8 + 2;
        return;
    }
}

static void get_json_length_dyn_limit_locationDef_limit_reqs_item_zone(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_zone_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_locationDef_limit_reqs_item_burst(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_burst_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_dyn_limit_locationDef_limit_reqs_item_delay(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_delay_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_locationDef_limit_reqs_item(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "zone": 
        get_json_length_dyn_limit_locationDef_limit_reqs_item_zone(pool, (&out->zone), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_burst_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "burst": 
        get_json_length_dyn_limit_locationDef_limit_reqs_item_burst(pool, (&out->burst), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_delay_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->delay.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (5 + 3); // "delay": 
        get_json_length_dyn_limit_locationDef_limit_reqs_item_delay(pool, (&out->delay), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_dyn_limit_locationDef_limit_reqs(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_locationDef_limit_reqs_item(pool, ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_req_dry_run(njt_pool_t *pool, dyn_limit_locationDef_limit_req_dry_run_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_ON) {
        // "on"
        *length += 2 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_OFF) {
        // "off"
        *length += 3 + 2;
        return;
    }
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_dyn_limit_locationDef_limit_req_log_level(njt_pool_t *pool, dyn_limit_locationDef_limit_req_log_level_t *out, size_t *length, njt_int_t flags) {
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_INFO) {
        // "info"
        *length += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_NOTICE) {
        // "notice"
        *length += 6 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_WARN) {
        // "warn"
        *length += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_ERROR) {
        // "error"
        *length += 5 + 2;
        return;
    }
}

static void get_json_length_dyn_limit_locationDef_limit_req_status(njt_pool_t *pool, dyn_limit_locationDef_limit_req_status_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_dyn_limit_locationDef_locations_item(njt_pool_t *pool, dyn_limit_locationDef_locations_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_dyn_limit_locationDef(pool, out, length, flags);
}

static void get_json_length_dyn_limit_locationDef_locations(njt_pool_t *pool, dyn_limit_locationDef_locations_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_locations_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_locationDef_locations_item(pool, ((dyn_limit_locationDef_locations_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit_locationDef(njt_pool_t *pool, dyn_limit_locationDef_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_location_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->location.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (8 + 3); // "location": 
        get_json_length_dyn_limit_locationDef_location(pool, (&out->location), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_rate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->limit_rate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (10 + 3); // "limit_rate": 
        get_json_length_dyn_limit_locationDef_limit_rate(pool, (&out->limit_rate), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_rate_after_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->limit_rate_after.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (16 + 3); // "limit_rate_after": 
        get_json_length_dyn_limit_locationDef_limit_rate_after(pool, (&out->limit_rate_after), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_conns_scope_set ? 0 : 1;
    if (omit == 0) {
        *length += (17 + 3); // "limit_conns_scope": 
        get_json_length_dyn_limit_locationDef_limit_conns_scope(pool, (&out->limit_conns_scope), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_conns_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_conns) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (11 + 3); // "limit_conns": 
        get_json_length_dyn_limit_locationDef_limit_conns(pool, (out->limit_conns), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_conn_dry_run_set ? 0 : 1;
    if (omit == 0) {
        *length += (18 + 3); // "limit_conn_dry_run": 
        get_json_length_dyn_limit_locationDef_limit_conn_dry_run(pool, (&out->limit_conn_dry_run), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_conn_log_level_set ? 0 : 1;
    if (omit == 0) {
        *length += (20 + 3); // "limit_conn_log_level": 
        get_json_length_dyn_limit_locationDef_limit_conn_log_level(pool, (&out->limit_conn_log_level), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_conn_status_set ? 0 : 1;
    if (omit == 0) {
        *length += (17 + 3); // "limit_conn_status": 
        get_json_length_dyn_limit_locationDef_limit_conn_status(pool, (&out->limit_conn_status), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_reqs_scope_set ? 0 : 1;
    if (omit == 0) {
        *length += (16 + 3); // "limit_reqs_scope": 
        get_json_length_dyn_limit_locationDef_limit_reqs_scope(pool, (&out->limit_reqs_scope), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_reqs_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_reqs) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (10 + 3); // "limit_reqs": 
        get_json_length_dyn_limit_locationDef_limit_reqs(pool, (out->limit_reqs), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_req_dry_run_set ? 0 : 1;
    if (omit == 0) {
        *length += (17 + 3); // "limit_req_dry_run": 
        get_json_length_dyn_limit_locationDef_limit_req_dry_run(pool, (&out->limit_req_dry_run), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_req_log_level_set ? 0 : 1;
    if (omit == 0) {
        *length += (19 + 3); // "limit_req_log_level": 
        get_json_length_dyn_limit_locationDef_limit_req_log_level(pool, (&out->limit_req_log_level), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_req_status_set ? 0 : 1;
    if (omit == 0) {
        *length += (16 + 3); // "limit_req_status": 
        get_json_length_dyn_limit_locationDef_limit_req_status(pool, (&out->limit_req_status), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_locations_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->locations) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "locations": 
        get_json_length_dyn_limit_locationDef_locations(pool, (out->locations), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

dyn_limit_locationDef_limit_conns_item_zone_t* get_dyn_limit_locationDef_limit_conns_item_zone(dyn_limit_locationDef_limit_conns_item_t *out) {
    return &out->zone;
}

dyn_limit_locationDef_limit_conns_item_conn_t get_dyn_limit_locationDef_limit_conns_item_conn(dyn_limit_locationDef_limit_conns_item_t *out) {
    return out->conn;
}
dyn_limit_locationDef_limit_conns_item_t* get_dyn_limit_locationDef_limit_conns_item(dyn_limit_locationDef_limit_conns_t *out, size_t idx) {
    return ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[idx];

}

dyn_limit_locationDef_limit_reqs_item_zone_t* get_dyn_limit_locationDef_limit_reqs_item_zone(dyn_limit_locationDef_limit_reqs_item_t *out) {
    return &out->zone;
}

dyn_limit_locationDef_limit_reqs_item_burst_t get_dyn_limit_locationDef_limit_reqs_item_burst(dyn_limit_locationDef_limit_reqs_item_t *out) {
    return out->burst;
}

dyn_limit_locationDef_limit_reqs_item_delay_t* get_dyn_limit_locationDef_limit_reqs_item_delay(dyn_limit_locationDef_limit_reqs_item_t *out) {
    return &out->delay;
}
dyn_limit_locationDef_limit_reqs_item_t* get_dyn_limit_locationDef_limit_reqs_item(dyn_limit_locationDef_limit_reqs_t *out, size_t idx) {
    return ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[idx];

}
dyn_limit_locationDef_locations_item_t* get_dyn_limit_locationDef_locations_item(dyn_limit_locationDef_locations_t *out, size_t idx) {
    return ((dyn_limit_locationDef_locations_item_t**)out->elts)[idx];

}

dyn_limit_locationDef_location_t* get_dyn_limit_locationDef_location(dyn_limit_locationDef_t *out) {
    return &out->location;
}

dyn_limit_locationDef_limit_rate_t* get_dyn_limit_locationDef_limit_rate(dyn_limit_locationDef_t *out) {
    return &out->limit_rate;
}

dyn_limit_locationDef_limit_rate_after_t* get_dyn_limit_locationDef_limit_rate_after(dyn_limit_locationDef_t *out) {
    return &out->limit_rate_after;
}

dyn_limit_locationDef_limit_conns_scope_t get_dyn_limit_locationDef_limit_conns_scope(dyn_limit_locationDef_t *out) {
    return out->limit_conns_scope;
}

dyn_limit_locationDef_limit_conns_t* get_dyn_limit_locationDef_limit_conns(dyn_limit_locationDef_t *out) {
    return out->limit_conns;
}

dyn_limit_locationDef_limit_conn_dry_run_t get_dyn_limit_locationDef_limit_conn_dry_run(dyn_limit_locationDef_t *out) {
    return out->limit_conn_dry_run;
}

dyn_limit_locationDef_limit_conn_log_level_t get_dyn_limit_locationDef_limit_conn_log_level(dyn_limit_locationDef_t *out) {
    return out->limit_conn_log_level;
}

dyn_limit_locationDef_limit_conn_status_t get_dyn_limit_locationDef_limit_conn_status(dyn_limit_locationDef_t *out) {
    return out->limit_conn_status;
}

dyn_limit_locationDef_limit_reqs_scope_t get_dyn_limit_locationDef_limit_reqs_scope(dyn_limit_locationDef_t *out) {
    return out->limit_reqs_scope;
}

dyn_limit_locationDef_limit_reqs_t* get_dyn_limit_locationDef_limit_reqs(dyn_limit_locationDef_t *out) {
    return out->limit_reqs;
}

dyn_limit_locationDef_limit_req_dry_run_t get_dyn_limit_locationDef_limit_req_dry_run(dyn_limit_locationDef_t *out) {
    return out->limit_req_dry_run;
}

dyn_limit_locationDef_limit_req_log_level_t get_dyn_limit_locationDef_limit_req_log_level(dyn_limit_locationDef_t *out) {
    return out->limit_req_log_level;
}

dyn_limit_locationDef_limit_req_status_t get_dyn_limit_locationDef_limit_req_status(dyn_limit_locationDef_t *out) {
    return out->limit_req_status;
}

dyn_limit_locationDef_locations_t* get_dyn_limit_locationDef_locations(dyn_limit_locationDef_t *out) {
    return out->locations;
}
void set_dyn_limit_locationDef_location(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_location_t* field) {
    njt_memcpy(&obj->location, field, sizeof(njt_str_t));
    obj->is_location_set = 1;
}
void set_dyn_limit_locationDef_limit_rate(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_rate_t* field) {
    njt_memcpy(&obj->limit_rate, field, sizeof(njt_str_t));
    obj->is_limit_rate_set = 1;
}
void set_dyn_limit_locationDef_limit_rate_after(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_rate_after_t* field) {
    njt_memcpy(&obj->limit_rate_after, field, sizeof(njt_str_t));
    obj->is_limit_rate_after_set = 1;
}
void set_dyn_limit_locationDef_limit_conns_scope(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_conns_scope_t field) {
    obj->limit_conns_scope = field;
    obj->is_limit_conns_scope_set = 1;
}
void set_dyn_limit_locationDef_limit_conns_item_zone(dyn_limit_locationDef_limit_conns_item_t* obj, dyn_limit_locationDef_limit_conns_item_zone_t* field) {
    njt_memcpy(&obj->zone, field, sizeof(njt_str_t));
    obj->is_zone_set = 1;
}
void set_dyn_limit_locationDef_limit_conns_item_conn(dyn_limit_locationDef_limit_conns_item_t* obj, dyn_limit_locationDef_limit_conns_item_conn_t field) {
    obj->conn = field;
    obj->is_conn_set = 1;
}
dyn_limit_locationDef_limit_conns_item_t* create_dyn_limit_locationDef_limit_conns_item(njt_pool_t *pool) {
    dyn_limit_locationDef_limit_conns_item_t* out = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_limit_conns_item_t));
    return out;
}
int add_item_dyn_limit_locationDef_limit_conns(dyn_limit_locationDef_limit_conns_t *src, dyn_limit_locationDef_limit_conns_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_locationDef_limit_conns_t* create_dyn_limit_locationDef_limit_conns(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_locationDef_limit_conns_item_t*));
}
void set_dyn_limit_locationDef_limit_conns(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_conns_t* field) {
    obj->limit_conns = field;
    obj->is_limit_conns_set = 1;
}
void set_dyn_limit_locationDef_limit_conn_dry_run(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_conn_dry_run_t field) {
    obj->limit_conn_dry_run = field;
    obj->is_limit_conn_dry_run_set = 1;
}
void set_dyn_limit_locationDef_limit_conn_log_level(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_conn_log_level_t field) {
    obj->limit_conn_log_level = field;
    obj->is_limit_conn_log_level_set = 1;
}
void set_dyn_limit_locationDef_limit_conn_status(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_conn_status_t field) {
    obj->limit_conn_status = field;
    obj->is_limit_conn_status_set = 1;
}
void set_dyn_limit_locationDef_limit_reqs_scope(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_reqs_scope_t field) {
    obj->limit_reqs_scope = field;
    obj->is_limit_reqs_scope_set = 1;
}
void set_dyn_limit_locationDef_limit_reqs_item_zone(dyn_limit_locationDef_limit_reqs_item_t* obj, dyn_limit_locationDef_limit_reqs_item_zone_t* field) {
    njt_memcpy(&obj->zone, field, sizeof(njt_str_t));
    obj->is_zone_set = 1;
}
void set_dyn_limit_locationDef_limit_reqs_item_burst(dyn_limit_locationDef_limit_reqs_item_t* obj, dyn_limit_locationDef_limit_reqs_item_burst_t field) {
    obj->burst = field;
    obj->is_burst_set = 1;
}
void set_dyn_limit_locationDef_limit_reqs_item_delay(dyn_limit_locationDef_limit_reqs_item_t* obj, dyn_limit_locationDef_limit_reqs_item_delay_t* field) {
    njt_memcpy(&obj->delay, field, sizeof(njt_str_t));
    obj->is_delay_set = 1;
}
dyn_limit_locationDef_limit_reqs_item_t* create_dyn_limit_locationDef_limit_reqs_item(njt_pool_t *pool) {
    dyn_limit_locationDef_limit_reqs_item_t* out = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_limit_reqs_item_t));
    return out;
}
int add_item_dyn_limit_locationDef_limit_reqs(dyn_limit_locationDef_limit_reqs_t *src, dyn_limit_locationDef_limit_reqs_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_locationDef_limit_reqs_t* create_dyn_limit_locationDef_limit_reqs(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_locationDef_limit_reqs_item_t*));
}
void set_dyn_limit_locationDef_limit_reqs(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_reqs_t* field) {
    obj->limit_reqs = field;
    obj->is_limit_reqs_set = 1;
}
void set_dyn_limit_locationDef_limit_req_dry_run(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_req_dry_run_t field) {
    obj->limit_req_dry_run = field;
    obj->is_limit_req_dry_run_set = 1;
}
void set_dyn_limit_locationDef_limit_req_log_level(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_req_log_level_t field) {
    obj->limit_req_log_level = field;
    obj->is_limit_req_log_level_set = 1;
}
void set_dyn_limit_locationDef_limit_req_status(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_limit_req_status_t field) {
    obj->limit_req_status = field;
    obj->is_limit_req_status_set = 1;
}
int add_item_dyn_limit_locationDef_locations(dyn_limit_locationDef_locations_t *src, dyn_limit_locationDef_locations_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_locationDef_locations_t* create_dyn_limit_locationDef_locations(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_locationDef_locations_item_t*));
}
void set_dyn_limit_locationDef_locations(dyn_limit_locationDef_t* obj, dyn_limit_locationDef_locations_t* field) {
    obj->locations = field;
    obj->is_locations_set = 1;
}
dyn_limit_locationDef_t* create_dyn_limit_locationDef(njt_pool_t *pool) {
    dyn_limit_locationDef_t* out = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_t));
    return out;
}

static void to_oneline_json_dyn_limit_locationDef_location(njt_pool_t *pool, dyn_limit_locationDef_location_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_rate(njt_pool_t *pool, dyn_limit_locationDef_limit_rate_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_rate_after(njt_pool_t *pool, dyn_limit_locationDef_limit_rate_after_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_conns_scope(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_scope_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_UP_SHARE) {
        cur = njt_sprintf(cur, "\"up_share\"");
        buf->len += 8 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONNS_SCOPE_LOCATION) {
        cur = njt_sprintf(cur, "\"location\"");
        buf->len += 8 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_conns_item_zone(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_zone_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_conns_item_conn(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_conn_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_conns_item(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"zone\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conns_item_zone(pool, (&out->zone), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_conn_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"conn\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conns_item_conn(pool, (&out->conn), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_locationDef_limit_conns(njt_pool_t *pool, dyn_limit_locationDef_limit_conns_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_locationDef_limit_conns_item(pool, ((dyn_limit_locationDef_limit_conns_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_locationDef_limit_conn_dry_run(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_dry_run_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_ON) {
        cur = njt_sprintf(cur, "\"on\"");
        buf->len += 2 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_DRY_RUN_OFF) {
        cur = njt_sprintf(cur, "\"off\"");
        buf->len += 3 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_conn_log_level(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_log_level_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_INFO) {
        cur = njt_sprintf(cur, "\"info\"");
        buf->len += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_NOTICE) {
        cur = njt_sprintf(cur, "\"notice\"");
        buf->len += 6 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_WARN) {
        cur = njt_sprintf(cur, "\"warn\"");
        buf->len += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_CONN_LOG_LEVEL_ERROR) {
        cur = njt_sprintf(cur, "\"error\"");
        buf->len += 5 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_conn_status(njt_pool_t *pool, dyn_limit_locationDef_limit_conn_status_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs_scope(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_scope_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_UP_SHARE) {
        cur = njt_sprintf(cur, "\"up_share\"");
        buf->len += 8 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQS_SCOPE_LOCATION) {
        cur = njt_sprintf(cur, "\"location\"");
        buf->len += 8 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs_item_zone(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_zone_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs_item_burst(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_burst_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs_item_delay(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_delay_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs_item(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"zone\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_reqs_item_zone(pool, (&out->zone), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_burst_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"burst\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_reqs_item_burst(pool, (&out->burst), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_delay_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->delay.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"delay\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_reqs_item_delay(pool, (&out->delay), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_locationDef_limit_reqs(njt_pool_t *pool, dyn_limit_locationDef_limit_reqs_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_locationDef_limit_reqs_item(pool, ((dyn_limit_locationDef_limit_reqs_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_locationDef_limit_req_dry_run(njt_pool_t *pool, dyn_limit_locationDef_limit_req_dry_run_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_ON) {
        cur = njt_sprintf(cur, "\"on\"");
        buf->len += 2 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_DRY_RUN_OFF) {
        cur = njt_sprintf(cur, "\"off\"");
        buf->len += 3 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_req_log_level(njt_pool_t *pool, dyn_limit_locationDef_limit_req_log_level_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_INFO) {
        cur = njt_sprintf(cur, "\"info\"");
        buf->len += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_NOTICE) {
        cur = njt_sprintf(cur, "\"notice\"");
        buf->len += 6 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_WARN) {
        cur = njt_sprintf(cur, "\"warn\"");
        buf->len += 4 + 2;
        return;
    }
    if (*out == DYN_LIMIT_LOCATIONDEF_LIMIT_REQ_LOG_LEVEL_ERROR) {
        cur = njt_sprintf(cur, "\"error\"");
        buf->len += 5 + 2;
        return;
    }
}

static void to_oneline_json_dyn_limit_locationDef_limit_req_status(njt_pool_t *pool, dyn_limit_locationDef_limit_req_status_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}
// to_oneline_json_REF

static void to_oneline_json_dyn_limit_locationDef_locations_item(njt_pool_t *pool, dyn_limit_locationDef_locations_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_dyn_limit_locationDef(pool, out, buf, flags);
}

static void to_oneline_json_dyn_limit_locationDef_locations(njt_pool_t *pool, dyn_limit_locationDef_locations_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_locationDef_locations_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_locationDef_locations_item(pool, ((dyn_limit_locationDef_locations_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_locationDef(njt_pool_t *pool, dyn_limit_locationDef_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_location_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->location.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"location\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_location(pool, (&out->location), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_rate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->limit_rate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_rate\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_rate(pool, (&out->limit_rate), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_rate_after_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->limit_rate_after.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_rate_after\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_rate_after(pool, (&out->limit_rate_after), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_conns_scope_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_conns_scope\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conns_scope(pool, (&out->limit_conns_scope), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_conns_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_conns) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_conns\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conns(pool, (out->limit_conns), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_conn_dry_run_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_conn_dry_run\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conn_dry_run(pool, (&out->limit_conn_dry_run), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_conn_log_level_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_conn_log_level\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conn_log_level(pool, (&out->limit_conn_log_level), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_conn_status_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_conn_status\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_conn_status(pool, (&out->limit_conn_status), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_reqs_scope_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_reqs_scope\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_reqs_scope(pool, (&out->limit_reqs_scope), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_reqs_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_reqs) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_reqs\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_reqs(pool, (out->limit_reqs), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_req_dry_run_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_req_dry_run\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_req_dry_run(pool, (&out->limit_req_dry_run), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_req_log_level_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_req_log_level\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_req_log_level(pool, (&out->limit_req_log_level), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_req_status_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_req_status\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_limit_req_status(pool, (&out->limit_req_status), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_locations_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->locations) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"locations\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_locationDef_locations(pool, (out->locations), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static bool parse_dyn_limit_servers_item_listens(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_servers_item_listens_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
        js2c_malloc_check(((&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]))->data);
        ((&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]))->len = token_size;
        if (builtin_parse_string(pool, parse_state, (&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]), 1, ((&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]))->len, err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_servers_item_serverNames(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_servers_item_serverNames_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
        js2c_malloc_check(((&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]))->data);
        ((&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]))->len = token_size;
        if (builtin_parse_string(pool, parse_state, (&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]), 0, ((&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]))->len, err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_servers_item_locations(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_servers_item_locations_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_servers_item_locations_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_locationDef_t));
        memset(((dyn_limit_servers_item_locations_item_t**)out->elts)[i], 0, sizeof(dyn_limit_servers_item_locations_item_t));
        if (parse_dyn_limit_locationDef(pool, parse_state, ((dyn_limit_servers_item_locations_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_servers_item(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_servers_item_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "listens")) {
            js2c_check_field_set(out->is_listens_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "listens";
            out->listens = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(njt_str_t));
            js2c_malloc_check(out->listens);

            if (parse_dyn_limit_servers_item_listens(pool, parse_state, (out->listens), err_ret)) {
                return true;
            }
            out->is_listens_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "serverNames")) {
            js2c_check_field_set(out->is_serverNames_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "serverNames";
            out->serverNames = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(njt_str_t));
            js2c_malloc_check(out->serverNames);

            if (parse_dyn_limit_servers_item_serverNames(pool, parse_state, (out->serverNames), err_ret)) {
                return true;
            }
            out->is_serverNames_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "locations")) {
            js2c_check_field_set(out->is_locations_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "locations";
            out->locations = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_servers_item_locations_item_t*));
            js2c_malloc_check(out->locations);

            if (parse_dyn_limit_servers_item_locations(pool, parse_state, (out->locations), err_ret)) {
                return true;
            }
            out->is_locations_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_listens_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': listens", parse_state->current_key);
        return true;
    }
    if (!out->is_serverNames_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': serverNames", parse_state->current_key);
        return true;
    }
    if (!out->is_locations_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': locations", parse_state->current_key);
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_dyn_limit_servers(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_servers_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_servers_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_servers_item_t));
        memset(((dyn_limit_servers_item_t**)out->elts)[i], 0, sizeof(dyn_limit_servers_item_t));
        if (parse_dyn_limit_servers_item(pool, parse_state, ((dyn_limit_servers_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit_limit_rps_item(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_limit_rps_item_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "zone")) {
            js2c_check_field_set(out->is_zone_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "zone";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->zone))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->zone))->data);
            ((&out->zone))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->zone), 0, ((&out->zone))->len, err_ret)) {
                return true;
            }
            out->is_zone_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "rate")) {
            js2c_check_field_set(out->is_rate_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "rate";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->rate))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->rate))->data);
            ((&out->rate))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->rate), 0, ((&out->rate))->len, err_ret)) {
                return true;
            }
            out->is_rate_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_zone_set) {
        size_t token_size = strlen("");
        (out->zone).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->zone).data);
        (out->zone).len = token_size;
        if (out->zone.len == 0) {
            (out->zone).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->zone.data, "", token_size);
        }
    }
    // set default
    if (!out->is_rate_set) {
        size_t token_size = strlen("");
        (out->rate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->rate).data);
        (out->rate).len = token_size;
        if (out->rate.len == 0) {
            (out->rate).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->rate.data, "", token_size);
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_dyn_limit_limit_rps(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_limit_rps_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((dyn_limit_limit_rps_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(dyn_limit_limit_rps_item_t));
        memset(((dyn_limit_limit_rps_item_t**)out->elts)[i], 0, sizeof(dyn_limit_limit_rps_item_t));
        if (parse_dyn_limit_limit_rps_item(pool, parse_state, ((dyn_limit_limit_rps_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dyn_limit(njt_pool_t *pool, parse_state_t *parse_state, dyn_limit_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "servers")) {
            js2c_check_field_set(out->is_servers_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "servers";
            out->servers = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_servers_item_t*));
            js2c_malloc_check(out->servers);

            if (parse_dyn_limit_servers(pool, parse_state, (out->servers), err_ret)) {
                return true;
            }
            out->is_servers_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "limit_rps")) {
            js2c_check_field_set(out->is_limit_rps_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "limit_rps";
            js2c_null_check();
            out->limit_rps = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dyn_limit_limit_rps_item_t*));
            js2c_malloc_check(out->limit_rps);

            if (parse_dyn_limit_limit_rps(pool, parse_state, (out->limit_rps), err_ret)) {
                return true;
            }
            out->is_limit_rps_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_servers_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': servers", parse_state->current_key);
        return true;
    }
    // set default
    if (!out->is_limit_rps_set) {
        out->limit_rps = njt_pcalloc(pool, sizeof(njt_array_t));
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_dyn_limit_servers_item_listens_item(njt_pool_t *pool, dyn_limit_servers_item_listens_item_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_servers_item_listens(njt_pool_t *pool, dyn_limit_servers_item_listens_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((dyn_limit_servers_item_listens_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_servers_item_listens_item(pool, (&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit_servers_item_serverNames_item(njt_pool_t *pool, dyn_limit_servers_item_serverNames_item_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_servers_item_serverNames(njt_pool_t *pool, dyn_limit_servers_item_serverNames_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_servers_item_serverNames_item(pool, (&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit_servers_item_locations_item(njt_pool_t *pool, dyn_limit_servers_item_locations_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_dyn_limit_locationDef(pool, out, length, flags);
}

static void get_json_length_dyn_limit_servers_item_locations(njt_pool_t *pool, dyn_limit_servers_item_locations_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_servers_item_locations_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_servers_item_locations_item(pool, ((dyn_limit_servers_item_locations_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit_servers_item(njt_pool_t *pool, dyn_limit_servers_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_listens_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->listens) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (7 + 3); // "listens": 
        get_json_length_dyn_limit_servers_item_listens(pool, (out->listens), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_serverNames_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->serverNames) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (11 + 3); // "serverNames": 
        get_json_length_dyn_limit_servers_item_serverNames(pool, (out->serverNames), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_locations_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->locations) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "locations": 
        get_json_length_dyn_limit_servers_item_locations(pool, (out->locations), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_dyn_limit_servers(njt_pool_t *pool, dyn_limit_servers_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_servers_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_servers_item(pool, ((dyn_limit_servers_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit_limit_rps_item_zone(njt_pool_t *pool, dyn_limit_limit_rps_item_zone_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_limit_rps_item_rate(njt_pool_t *pool, dyn_limit_limit_rps_item_rate_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_dyn_limit_limit_rps_item(njt_pool_t *pool, dyn_limit_limit_rps_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "zone": 
        get_json_length_dyn_limit_limit_rps_item_zone(pool, (&out->zone), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_rate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->rate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "rate": 
        get_json_length_dyn_limit_limit_rps_item_rate(pool, (&out->rate), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_dyn_limit_limit_rps(njt_pool_t *pool, dyn_limit_limit_rps_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_limit_rps_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_dyn_limit_limit_rps_item(pool, ((dyn_limit_limit_rps_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dyn_limit(njt_pool_t *pool, dyn_limit_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_servers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->servers) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (7 + 3); // "servers": 
        get_json_length_dyn_limit_servers(pool, (out->servers), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_limit_rps_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_rps) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "limit_rps": 
        get_json_length_dyn_limit_limit_rps(pool, (out->limit_rps), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}
dyn_limit_servers_item_listens_item_t* get_dyn_limit_servers_item_listens_item(dyn_limit_servers_item_listens_t *out, size_t idx) {
    return &((dyn_limit_servers_item_listens_item_t*)out->elts)[idx];

}
dyn_limit_servers_item_serverNames_item_t* get_dyn_limit_servers_item_serverNames_item(dyn_limit_servers_item_serverNames_t *out, size_t idx) {
    return &((dyn_limit_servers_item_serverNames_item_t*)out->elts)[idx];

}
dyn_limit_servers_item_locations_item_t* get_dyn_limit_servers_item_locations_item(dyn_limit_servers_item_locations_t *out, size_t idx) {
    return ((dyn_limit_servers_item_locations_item_t**)out->elts)[idx];

}

dyn_limit_servers_item_listens_t* get_dyn_limit_servers_item_listens(dyn_limit_servers_item_t *out) {
    return out->listens;
}

dyn_limit_servers_item_serverNames_t* get_dyn_limit_servers_item_serverNames(dyn_limit_servers_item_t *out) {
    return out->serverNames;
}

dyn_limit_servers_item_locations_t* get_dyn_limit_servers_item_locations(dyn_limit_servers_item_t *out) {
    return out->locations;
}
dyn_limit_servers_item_t* get_dyn_limit_servers_item(dyn_limit_servers_t *out, size_t idx) {
    return ((dyn_limit_servers_item_t**)out->elts)[idx];

}

dyn_limit_limit_rps_item_zone_t* get_dyn_limit_limit_rps_item_zone(dyn_limit_limit_rps_item_t *out) {
    return &out->zone;
}

dyn_limit_limit_rps_item_rate_t* get_dyn_limit_limit_rps_item_rate(dyn_limit_limit_rps_item_t *out) {
    return &out->rate;
}
dyn_limit_limit_rps_item_t* get_dyn_limit_limit_rps_item(dyn_limit_limit_rps_t *out, size_t idx) {
    return ((dyn_limit_limit_rps_item_t**)out->elts)[idx];

}

dyn_limit_servers_t* get_dyn_limit_servers(dyn_limit_t *out) {
    return out->servers;
}

dyn_limit_limit_rps_t* get_dyn_limit_limit_rps(dyn_limit_t *out) {
    return out->limit_rps;
}
int add_item_dyn_limit_servers_item_listens(dyn_limit_servers_item_listens_t *src, dyn_limit_servers_item_listens_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, item, src->size);
    return NJT_OK;
}

dyn_limit_servers_item_listens_t* create_dyn_limit_servers_item_listens(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_servers_item_listens_item_t));
}
void set_dyn_limit_servers_item_listens(dyn_limit_servers_item_t* obj, dyn_limit_servers_item_listens_t* field) {
    obj->listens = field;
    obj->is_listens_set = 1;
}
int add_item_dyn_limit_servers_item_serverNames(dyn_limit_servers_item_serverNames_t *src, dyn_limit_servers_item_serverNames_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, item, src->size);
    return NJT_OK;
}

dyn_limit_servers_item_serverNames_t* create_dyn_limit_servers_item_serverNames(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_servers_item_serverNames_item_t));
}
void set_dyn_limit_servers_item_serverNames(dyn_limit_servers_item_t* obj, dyn_limit_servers_item_serverNames_t* field) {
    obj->serverNames = field;
    obj->is_serverNames_set = 1;
}
int add_item_dyn_limit_servers_item_locations(dyn_limit_servers_item_locations_t *src, dyn_limit_servers_item_locations_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_servers_item_locations_t* create_dyn_limit_servers_item_locations(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_servers_item_locations_item_t*));
}
void set_dyn_limit_servers_item_locations(dyn_limit_servers_item_t* obj, dyn_limit_servers_item_locations_t* field) {
    obj->locations = field;
    obj->is_locations_set = 1;
}
dyn_limit_servers_item_t* create_dyn_limit_servers_item(njt_pool_t *pool) {
    dyn_limit_servers_item_t* out = njt_pcalloc(pool, sizeof(dyn_limit_servers_item_t));
    return out;
}
int add_item_dyn_limit_servers(dyn_limit_servers_t *src, dyn_limit_servers_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_servers_t* create_dyn_limit_servers(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_servers_item_t*));
}
void set_dyn_limit_servers(dyn_limit_t* obj, dyn_limit_servers_t* field) {
    obj->servers = field;
    obj->is_servers_set = 1;
}
void set_dyn_limit_limit_rps_item_zone(dyn_limit_limit_rps_item_t* obj, dyn_limit_limit_rps_item_zone_t* field) {
    njt_memcpy(&obj->zone, field, sizeof(njt_str_t));
    obj->is_zone_set = 1;
}
void set_dyn_limit_limit_rps_item_rate(dyn_limit_limit_rps_item_t* obj, dyn_limit_limit_rps_item_rate_t* field) {
    njt_memcpy(&obj->rate, field, sizeof(njt_str_t));
    obj->is_rate_set = 1;
}
dyn_limit_limit_rps_item_t* create_dyn_limit_limit_rps_item(njt_pool_t *pool) {
    dyn_limit_limit_rps_item_t* out = njt_pcalloc(pool, sizeof(dyn_limit_limit_rps_item_t));
    return out;
}
int add_item_dyn_limit_limit_rps(dyn_limit_limit_rps_t *src, dyn_limit_limit_rps_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dyn_limit_limit_rps_t* create_dyn_limit_limit_rps(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(dyn_limit_limit_rps_item_t*));
}
void set_dyn_limit_limit_rps(dyn_limit_t* obj, dyn_limit_limit_rps_t* field) {
    obj->limit_rps = field;
    obj->is_limit_rps_set = 1;
}
dyn_limit_t* create_dyn_limit(njt_pool_t *pool) {
    dyn_limit_t* out = njt_pcalloc(pool, sizeof(dyn_limit_t));
    return out;
}

static void to_oneline_json_dyn_limit_servers_item_listens_item(njt_pool_t *pool, dyn_limit_servers_item_listens_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_servers_item_listens(njt_pool_t *pool, dyn_limit_servers_item_listens_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((dyn_limit_servers_item_listens_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_servers_item_listens_item(pool, (&((dyn_limit_servers_item_listens_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_servers_item_serverNames_item(njt_pool_t *pool, dyn_limit_servers_item_serverNames_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_servers_item_serverNames(njt_pool_t *pool, dyn_limit_servers_item_serverNames_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_servers_item_serverNames_item(pool, (&((dyn_limit_servers_item_serverNames_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}
// to_oneline_json_REF

static void to_oneline_json_dyn_limit_servers_item_locations_item(njt_pool_t *pool, dyn_limit_servers_item_locations_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_dyn_limit_locationDef(pool, out, buf, flags);
}

static void to_oneline_json_dyn_limit_servers_item_locations(njt_pool_t *pool, dyn_limit_servers_item_locations_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_servers_item_locations_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_servers_item_locations_item(pool, ((dyn_limit_servers_item_locations_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_servers_item(njt_pool_t *pool, dyn_limit_servers_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_listens_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->listens) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"listens\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_servers_item_listens(pool, (out->listens), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_serverNames_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->serverNames) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"serverNames\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_servers_item_serverNames(pool, (out->serverNames), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_locations_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->locations) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"locations\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_servers_item_locations(pool, (out->locations), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_servers(njt_pool_t *pool, dyn_limit_servers_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_servers_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_servers_item(pool, ((dyn_limit_servers_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_limit_rps_item_zone(njt_pool_t *pool, dyn_limit_limit_rps_item_zone_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_limit_rps_item_rate(njt_pool_t *pool, dyn_limit_limit_rps_item_rate_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_dyn_limit_limit_rps_item(njt_pool_t *pool, dyn_limit_limit_rps_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"zone\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_limit_rps_item_zone(pool, (&out->zone), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_rate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->rate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"rate\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_limit_rps_item_rate(pool, (&out->rate), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_dyn_limit_limit_rps(njt_pool_t *pool, dyn_limit_limit_rps_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((dyn_limit_limit_rps_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_dyn_limit_limit_rps_item(pool, ((dyn_limit_limit_rps_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dyn_limit(njt_pool_t *pool, dyn_limit_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_servers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->servers) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"servers\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_servers(pool, (out->servers), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_limit_rps_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->limit_rps) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"limit_rps\":");
        buf->len = cur - buf->data;
        to_oneline_json_dyn_limit_limit_rps(pool, (out->limit_rps), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
dyn_limit_t* json_parse_dyn_limit(njt_pool_t *pool, const njt_str_t *json_string, js2c_parse_error_t *err_ret) {
    dyn_limit_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_pcalloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_ret);
        if (parse_result == JSMN_ERROR_INVAL) {
            LOG_ERROR_JSON_PARSE(INVALID_JSON_CHAR_ERR, "", -1, "%s", "Invalid character inside JSON string");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_PART) {
            LOG_ERROR_JSON_PARSE(PARTIAL_JSON_ERR, "", -1, "%s", "The string is not a full JSON packet, more bytes expected");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(NULL_JSON_ERR, "", 0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_pcalloc(pool, sizeof(dyn_limit_t));;
    memset(out, 0, sizeof(dyn_limit_t));
    if (parse_dyn_limit(pool, parse_state, out, err_ret)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_dyn_limit(njt_pool_t *pool, dyn_limit_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_pcalloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_dyn_limit(pool, out, &str_len, flags);
    json_str->data = (u_char*)njt_pcalloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_dyn_limit(pool, out, json_str, flags);
    return json_str;
}
