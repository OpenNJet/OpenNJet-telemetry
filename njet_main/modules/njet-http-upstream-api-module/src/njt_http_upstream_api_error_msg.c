

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_http_upstream_api_error_msg.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */


static bool parse_upstream_error_msg_error(njt_pool_t *pool, parse_state_t *parse_state, upstream_error_msg_error_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "status")) {
            js2c_check_field_set(out->is_status_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "status";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->status) = int_parse_tmp;
            out->is_status_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "text")) {
            js2c_check_field_set(out->is_text_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "text";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->text))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->text))->data);
            ((&out->text))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->text), 0, ((&out->text))->len, err_ret)) {
                return true;
            }
            out->is_text_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "code")) {
            js2c_check_field_set(out->is_code_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "code";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->code))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->code))->data);
            ((&out->code))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->code), 0, ((&out->code))->len, err_ret)) {
                return true;
            }
            out->is_code_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_upstream_error_msg(njt_pool_t *pool, parse_state_t *parse_state, upstream_error_msg_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "error")) {
            js2c_check_field_set(out->is_error_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "error";
            out->error = njt_pcalloc(pool, sizeof(upstream_error_msg_error_t));
            js2c_malloc_check(out->error);
            memset(out->error, 0, sizeof(upstream_error_msg_error_t));

            if (parse_upstream_error_msg_error(pool, parse_state, (out->error), err_ret)) {
                return true;
            }
            out->is_error_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "request_id")) {
            js2c_check_field_set(out->is_request_id_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "request_id";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->request_id))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->request_id))->data);
            ((&out->request_id))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->request_id), 0, ((&out->request_id))->len, err_ret)) {
                return true;
            }
            out->is_request_id_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "href")) {
            js2c_check_field_set(out->is_href_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "href";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->href))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->href))->data);
            ((&out->href))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->href), 0, ((&out->href))->len, err_ret)) {
                return true;
            }
            out->is_href_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_error_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': error", parse_state->current_key);
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_upstream_error_msg_error_status(njt_pool_t *pool, upstream_error_msg_error_status_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_error_msg_error_text(njt_pool_t *pool, upstream_error_msg_error_text_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_error_msg_error_code(njt_pool_t *pool, upstream_error_msg_error_code_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_error_msg_error(njt_pool_t *pool, upstream_error_msg_error_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_status_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "status": 
        get_json_length_upstream_error_msg_error_status(pool, (&out->status), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_text_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->text.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "text": 
        get_json_length_upstream_error_msg_error_text(pool, (&out->text), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_code_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->code.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "code": 
        get_json_length_upstream_error_msg_error_code(pool, (&out->code), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_upstream_error_msg_request_id(njt_pool_t *pool, upstream_error_msg_request_id_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_error_msg_href(njt_pool_t *pool, upstream_error_msg_href_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_error_msg(njt_pool_t *pool, upstream_error_msg_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_error_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->error) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (5 + 3); // "error": 
        get_json_length_upstream_error_msg_error(pool, (out->error), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_request_id_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->request_id.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (10 + 3); // "request_id": 
        get_json_length_upstream_error_msg_request_id(pool, (&out->request_id), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_href_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->href.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "href": 
        get_json_length_upstream_error_msg_href(pool, (&out->href), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

upstream_error_msg_error_status_t get_upstream_error_msg_error_status(upstream_error_msg_error_t *out) {
    return out->status;
}

upstream_error_msg_error_text_t* get_upstream_error_msg_error_text(upstream_error_msg_error_t *out) {
    return &out->text;
}

upstream_error_msg_error_code_t* get_upstream_error_msg_error_code(upstream_error_msg_error_t *out) {
    return &out->code;
}

upstream_error_msg_error_t* get_upstream_error_msg_error(upstream_error_msg_t *out) {
    return out->error;
}

upstream_error_msg_request_id_t* get_upstream_error_msg_request_id(upstream_error_msg_t *out) {
    return &out->request_id;
}

upstream_error_msg_href_t* get_upstream_error_msg_href(upstream_error_msg_t *out) {
    return &out->href;
}
void set_upstream_error_msg_error_status(upstream_error_msg_error_t* obj, upstream_error_msg_error_status_t field) {
    obj->status = field;
    obj->is_status_set = 1;
}
void set_upstream_error_msg_error_text(upstream_error_msg_error_t* obj, upstream_error_msg_error_text_t* field) {
    njt_memcpy(&obj->text, field, sizeof(njt_str_t));
    obj->is_text_set = 1;
}
void set_upstream_error_msg_error_code(upstream_error_msg_error_t* obj, upstream_error_msg_error_code_t* field) {
    njt_memcpy(&obj->code, field, sizeof(njt_str_t));
    obj->is_code_set = 1;
}
upstream_error_msg_error_t* create_upstream_error_msg_error(njt_pool_t *pool) {
    upstream_error_msg_error_t* out = njt_pcalloc(pool, sizeof(upstream_error_msg_error_t));
    return out;
}
void set_upstream_error_msg_error(upstream_error_msg_t* obj, upstream_error_msg_error_t* field) {
    obj->error = field;
    obj->is_error_set = 1;
}
void set_upstream_error_msg_request_id(upstream_error_msg_t* obj, upstream_error_msg_request_id_t* field) {
    njt_memcpy(&obj->request_id, field, sizeof(njt_str_t));
    obj->is_request_id_set = 1;
}
void set_upstream_error_msg_href(upstream_error_msg_t* obj, upstream_error_msg_href_t* field) {
    njt_memcpy(&obj->href, field, sizeof(njt_str_t));
    obj->is_href_set = 1;
}
upstream_error_msg_t* create_upstream_error_msg(njt_pool_t *pool) {
    upstream_error_msg_t* out = njt_pcalloc(pool, sizeof(upstream_error_msg_t));
    return out;
}

static void to_oneline_json_upstream_error_msg_error_status(njt_pool_t *pool, upstream_error_msg_error_status_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_error_msg_error_text(njt_pool_t *pool, upstream_error_msg_error_text_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_error_msg_error_code(njt_pool_t *pool, upstream_error_msg_error_code_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_error_msg_error(njt_pool_t *pool, upstream_error_msg_error_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_status_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"status\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_error_status(pool, (&out->status), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_text_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->text.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"text\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_error_text(pool, (&out->text), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_code_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->code.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"code\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_error_code(pool, (&out->code), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_upstream_error_msg_request_id(njt_pool_t *pool, upstream_error_msg_request_id_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_error_msg_href(njt_pool_t *pool, upstream_error_msg_href_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_error_msg(njt_pool_t *pool, upstream_error_msg_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_error_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->error) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"error\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_error(pool, (out->error), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_request_id_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->request_id.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"request_id\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_request_id(pool, (&out->request_id), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_href_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->href.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"href\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_error_msg_href(pool, (&out->href), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
upstream_error_msg_t* json_parse_upstream_error_msg(njt_pool_t *pool, const njt_str_t *json_string, js2c_parse_error_t *err_ret) {
    upstream_error_msg_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_pcalloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_ret);
        if (parse_result == JSMN_ERROR_INVAL) {
            LOG_ERROR_JSON_PARSE(INVALID_JSON_CHAR_ERR, "", -1, "%s", "Invalid character inside JSON string");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_PART) {
            LOG_ERROR_JSON_PARSE(PARTIAL_JSON_ERR, "", -1, "%s", "The string is not a full JSON packet, more bytes expected");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(NULL_JSON_ERR, "", 0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_pcalloc(pool, sizeof(upstream_error_msg_t));;
    memset(out, 0, sizeof(upstream_error_msg_t));
    if (parse_upstream_error_msg(pool, parse_state, out, err_ret)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_upstream_error_msg(njt_pool_t *pool, upstream_error_msg_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_pcalloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_upstream_error_msg(pool, out, &str_len, flags);
    json_str->data = (u_char*)njt_pcalloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_upstream_error_msg(pool, out, json_str, flags);
    return json_str;
}
