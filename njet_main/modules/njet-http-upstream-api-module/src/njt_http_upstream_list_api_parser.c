

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_http_upstream_list_api_parser.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */

static bool parse_upstream_list_peerDef(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_peerDef_t *out, js2c_parse_error_t *err_ret); //forward decl for public definition
static void get_json_length_upstream_list_peerDef(njt_pool_t *pool, upstream_list_peerDef_t *out, size_t *length, njt_int_t flags); //forward decl for public definition
static void to_oneline_json_upstream_list_peerDef(njt_pool_t *pool, upstream_list_peerDef_t *out, njt_str_t *buf, njt_int_t flags); //forward decl for public definition

static bool parse_upstream_list_peerDef_responses(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_peerDef_responses_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "one")) {
            js2c_check_field_set(out->is_one_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "one";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->one) = int_parse_tmp;
            out->is_one_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "two")) {
            js2c_check_field_set(out->is_two_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "two";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->two) = int_parse_tmp;
            out->is_two_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "three")) {
            js2c_check_field_set(out->is_three_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "three";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->three) = int_parse_tmp;
            out->is_three_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "four")) {
            js2c_check_field_set(out->is_four_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "four";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->four) = int_parse_tmp;
            out->is_four_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "five")) {
            js2c_check_field_set(out->is_five_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "five";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->five) = int_parse_tmp;
            out->is_five_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "codes")) {
            js2c_check_field_set(out->is_codes_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "codes";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->codes))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->codes))->data);
            ((&out->codes))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->codes), 0, ((&out->codes))->len, err_ret)) {
                return true;
            }
            out->is_codes_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "total")) {
            js2c_check_field_set(out->is_total_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "total";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->total) = int_parse_tmp;
            out->is_total_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_one_set) {
        out->one = 0LL;
    }
    // set default
    if (!out->is_two_set) {
        out->two = 0LL;
    }
    // set default
    if (!out->is_three_set) {
        out->three = 0LL;
    }
    // set default
    if (!out->is_four_set) {
        out->four = 0LL;
    }
    // set default
    if (!out->is_five_set) {
        out->five = 0LL;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_upstream_list_peerDef_health_checks(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_peerDef_health_checks_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "checks")) {
            js2c_check_field_set(out->is_checks_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "checks";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->checks) = int_parse_tmp;
            out->is_checks_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "fails")) {
            js2c_check_field_set(out->is_fails_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "fails";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->fails) = int_parse_tmp;
            out->is_fails_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "unhealthy")) {
            js2c_check_field_set(out->is_unhealthy_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "unhealthy";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->unhealthy) = int_parse_tmp;
            out->is_unhealthy_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "last_passed")) {
            js2c_check_field_set(out->is_last_passed_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "last_passed";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->last_passed), err_ret)) {
                return true;
            }
            out->is_last_passed_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_last_passed_set) {
        out->last_passed = true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_upstream_list_peerDef(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_peerDef_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "id")) {
            js2c_check_field_set(out->is_id_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "id";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->id) = int_parse_tmp;
            out->is_id_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "server")) {
            js2c_check_field_set(out->is_server_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "server";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->server))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->server))->data);
            ((&out->server))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->server), 0, ((&out->server))->len, err_ret)) {
                return true;
            }
            out->is_server_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "name")) {
            js2c_check_field_set(out->is_name_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "name";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->name))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->name))->data);
            ((&out->name))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->name), 0, ((&out->name))->len, err_ret)) {
                return true;
            }
            out->is_name_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "backup")) {
            js2c_check_field_set(out->is_backup_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "backup";
            if (builtin_parse_bool(pool, parse_state, (&out->backup), err_ret)) {
                return true;
            }
            out->is_backup_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "weight")) {
            js2c_check_field_set(out->is_weight_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "weight";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->weight) = int_parse_tmp;
            out->is_weight_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "state")) {
            js2c_check_field_set(out->is_state_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "state";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->state))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->state))->data);
            ((&out->state))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->state), 0, ((&out->state))->len, err_ret)) {
                return true;
            }
            out->is_state_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "active")) {
            js2c_check_field_set(out->is_active_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "active";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->active) = int_parse_tmp;
            out->is_active_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "max_conns")) {
            js2c_check_field_set(out->is_max_conns_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "max_conns";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->max_conns) = int_parse_tmp;
            out->is_max_conns_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "requests")) {
            js2c_check_field_set(out->is_requests_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "requests";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->requests) = int_parse_tmp;
            out->is_requests_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "connections")) {
            js2c_check_field_set(out->is_connections_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "connections";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->connections) = int_parse_tmp;
            out->is_connections_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "connect_time")) {
            js2c_check_field_set(out->is_connect_time_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "connect_time";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->connect_time) = int_parse_tmp;
            out->is_connect_time_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "first_byte_time")) {
            js2c_check_field_set(out->is_first_byte_time_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "first_byte_time";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->first_byte_time) = int_parse_tmp;
            out->is_first_byte_time_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "responses")) {
            js2c_check_field_set(out->is_responses_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "responses";
            js2c_null_check();
            out->responses = njt_pcalloc(pool, sizeof(upstream_list_peerDef_responses_t));
            js2c_malloc_check(out->responses);
            memset(out->responses, 0, sizeof(upstream_list_peerDef_responses_t));

            if (parse_upstream_list_peerDef_responses(pool, parse_state, (out->responses), err_ret)) {
                return true;
            }
            out->is_responses_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "sent")) {
            js2c_check_field_set(out->is_sent_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "sent";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->sent) = int_parse_tmp;
            out->is_sent_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "received")) {
            js2c_check_field_set(out->is_received_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "received";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->received) = int_parse_tmp;
            out->is_received_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "fails")) {
            js2c_check_field_set(out->is_fails_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "fails";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->fails) = int_parse_tmp;
            out->is_fails_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "unavail")) {
            js2c_check_field_set(out->is_unavail_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "unavail";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->unavail) = int_parse_tmp;
            out->is_unavail_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "health_checks")) {
            js2c_check_field_set(out->is_health_checks_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "health_checks";
            js2c_null_check();
            out->health_checks = njt_pcalloc(pool, sizeof(upstream_list_peerDef_health_checks_t));
            js2c_malloc_check(out->health_checks);
            memset(out->health_checks, 0, sizeof(upstream_list_peerDef_health_checks_t));

            if (parse_upstream_list_peerDef_health_checks(pool, parse_state, (out->health_checks), err_ret)) {
                return true;
            }
            out->is_health_checks_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "downtime")) {
            js2c_check_field_set(out->is_downtime_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "downtime";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->downtime) = int_parse_tmp;
            out->is_downtime_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "downstart")) {
            js2c_check_field_set(out->is_downstart_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "downstart";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->downstart))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->downstart))->data);
            ((&out->downstart))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->downstart), 0, ((&out->downstart))->len, err_ret)) {
                return true;
            }
            out->is_downstart_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "selected")) {
            js2c_check_field_set(out->is_selected_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "selected";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->selected))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->selected))->data);
            ((&out->selected))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->selected), 0, ((&out->selected))->len, err_ret)) {
                return true;
            }
            out->is_selected_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "header_time")) {
            js2c_check_field_set(out->is_header_time_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "header_time";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->header_time) = int_parse_tmp;
            out->is_header_time_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "response_time")) {
            js2c_check_field_set(out->is_response_time_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "response_time";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->response_time) = int_parse_tmp;
            out->is_response_time_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_max_conns_set) {
        out->max_conns = 0LL;
    }
    // set default
    if (!out->is_requests_set) {
        out->requests = 0LL;
    }
    // set default
    if (!out->is_connections_set) {
        out->connections = 0LL;
    }
    // set default
    if (!out->is_connect_time_set) {
        out->connect_time = 0LL;
    }
    // set default
    if (!out->is_first_byte_time_set) {
        out->first_byte_time = 0LL;
    }
    // set default
    if (!out->is_responses_set) {
        out->responses = NULL;
    }
    // set default
    if (!out->is_sent_set) {
        out->sent = 0LL;
    }
    // set default
    if (!out->is_received_set) {
        out->received = 0LL;
    }
    // set default
    if (!out->is_fails_set) {
        out->fails = 0LL;
    }
    // set default
    if (!out->is_unavail_set) {
        out->unavail = 0LL;
    }
    // set default
    if (!out->is_health_checks_set) {
        out->health_checks = NULL;
    }
    // set default
    if (!out->is_downtime_set) {
        out->downtime = 0LL;
    }
    // set default
    if (!out->is_downstart_set) {
        size_t token_size = strlen("{}");
        (out->downstart).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->downstart).data);
        (out->downstart).len = token_size;
        if (out->downstart.len == 0) {
            (out->downstart).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->downstart.data, "{}", token_size);
        }
    }
    // set default
    if (!out->is_selected_set) {
        size_t token_size = strlen("{}");
        (out->selected).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->selected).data);
        (out->selected).len = token_size;
        if (out->selected.len == 0) {
            (out->selected).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->selected.data, "{}", token_size);
        }
    }
    // set default
    if (!out->is_header_time_set) {
        out->header_time = 0LL;
    }
    // set default
    if (!out->is_response_time_set) {
        out->response_time = 0LL;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_upstream_list_peerDef_id(njt_pool_t *pool, upstream_list_peerDef_id_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_server(njt_pool_t *pool, upstream_list_peerDef_server_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_name(njt_pool_t *pool, upstream_list_peerDef_name_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_backup(njt_pool_t *pool, upstream_list_peerDef_backup_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_upstream_list_peerDef_weight(njt_pool_t *pool, upstream_list_peerDef_weight_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_state(njt_pool_t *pool, upstream_list_peerDef_state_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_active(njt_pool_t *pool, upstream_list_peerDef_active_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_max_conns(njt_pool_t *pool, upstream_list_peerDef_max_conns_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_requests(njt_pool_t *pool, upstream_list_peerDef_requests_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_connections(njt_pool_t *pool, upstream_list_peerDef_connections_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_connect_time(njt_pool_t *pool, upstream_list_peerDef_connect_time_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_first_byte_time(njt_pool_t *pool, upstream_list_peerDef_first_byte_time_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_one(njt_pool_t *pool, upstream_list_peerDef_responses_one_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_two(njt_pool_t *pool, upstream_list_peerDef_responses_two_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_three(njt_pool_t *pool, upstream_list_peerDef_responses_three_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_four(njt_pool_t *pool, upstream_list_peerDef_responses_four_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_five(njt_pool_t *pool, upstream_list_peerDef_responses_five_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses_codes(njt_pool_t *pool, upstream_list_peerDef_responses_codes_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_responses_total(njt_pool_t *pool, upstream_list_peerDef_responses_total_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_responses(njt_pool_t *pool, upstream_list_peerDef_responses_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_one_set ? 0 : 1;
    if (omit == 0) {
        *length += (3 + 3); // "one": 
        get_json_length_upstream_list_peerDef_responses_one(pool, (&out->one), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_two_set ? 0 : 1;
    if (omit == 0) {
        *length += (3 + 3); // "two": 
        get_json_length_upstream_list_peerDef_responses_two(pool, (&out->two), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_three_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "three": 
        get_json_length_upstream_list_peerDef_responses_three(pool, (&out->three), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_four_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "four": 
        get_json_length_upstream_list_peerDef_responses_four(pool, (&out->four), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_five_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "five": 
        get_json_length_upstream_list_peerDef_responses_five(pool, (&out->five), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_codes_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->codes.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (5 + 3); // "codes": 
        get_json_length_upstream_list_peerDef_responses_codes(pool, (&out->codes), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_total_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "total": 
        get_json_length_upstream_list_peerDef_responses_total(pool, (&out->total), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_upstream_list_peerDef_sent(njt_pool_t *pool, upstream_list_peerDef_sent_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_received(njt_pool_t *pool, upstream_list_peerDef_received_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_fails(njt_pool_t *pool, upstream_list_peerDef_fails_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_unavail(njt_pool_t *pool, upstream_list_peerDef_unavail_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_health_checks_checks(njt_pool_t *pool, upstream_list_peerDef_health_checks_checks_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_health_checks_fails(njt_pool_t *pool, upstream_list_peerDef_health_checks_fails_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_health_checks_unhealthy(njt_pool_t *pool, upstream_list_peerDef_health_checks_unhealthy_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_health_checks_last_passed(njt_pool_t *pool, upstream_list_peerDef_health_checks_last_passed_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_upstream_list_peerDef_health_checks(njt_pool_t *pool, upstream_list_peerDef_health_checks_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_checks_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "checks": 
        get_json_length_upstream_list_peerDef_health_checks_checks(pool, (&out->checks), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "fails": 
        get_json_length_upstream_list_peerDef_health_checks_fails(pool, (&out->fails), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_unhealthy_set ? 0 : 1;
    if (omit == 0) {
        *length += (9 + 3); // "unhealthy": 
        get_json_length_upstream_list_peerDef_health_checks_unhealthy(pool, (&out->unhealthy), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_last_passed_set ? 0 : 1;
    if (omit == 0) {
        *length += (11 + 3); // "last_passed": 
        get_json_length_upstream_list_peerDef_health_checks_last_passed(pool, (&out->last_passed), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_upstream_list_peerDef_downtime(njt_pool_t *pool, upstream_list_peerDef_downtime_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_downstart(njt_pool_t *pool, upstream_list_peerDef_downstart_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_selected(njt_pool_t *pool, upstream_list_peerDef_selected_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_peerDef_header_time(njt_pool_t *pool, upstream_list_peerDef_header_time_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef_response_time(njt_pool_t *pool, upstream_list_peerDef_response_time_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_peerDef(njt_pool_t *pool, upstream_list_peerDef_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_id_set ? 0 : 1;
    if (omit == 0) {
        *length += (2 + 3); // "id": 
        get_json_length_upstream_list_peerDef_id(pool, (&out->id), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_server_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->server.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "server": 
        get_json_length_upstream_list_peerDef_server(pool, (&out->server), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "name": 
        get_json_length_upstream_list_peerDef_name(pool, (&out->name), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_backup_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "backup": 
        get_json_length_upstream_list_peerDef_backup(pool, (&out->backup), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_weight_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "weight": 
        get_json_length_upstream_list_peerDef_weight(pool, (&out->weight), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_state_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->state.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (5 + 3); // "state": 
        get_json_length_upstream_list_peerDef_state(pool, (&out->state), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_active_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "active": 
        get_json_length_upstream_list_peerDef_active(pool, (&out->active), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_max_conns_set ? 0 : 1;
    if (omit == 0) {
        *length += (9 + 3); // "max_conns": 
        get_json_length_upstream_list_peerDef_max_conns(pool, (&out->max_conns), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_requests_set ? 0 : 1;
    if (omit == 0) {
        *length += (8 + 3); // "requests": 
        get_json_length_upstream_list_peerDef_requests(pool, (&out->requests), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_connections_set ? 0 : 1;
    if (omit == 0) {
        *length += (11 + 3); // "connections": 
        get_json_length_upstream_list_peerDef_connections(pool, (&out->connections), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_connect_time_set ? 0 : 1;
    if (omit == 0) {
        *length += (12 + 3); // "connect_time": 
        get_json_length_upstream_list_peerDef_connect_time(pool, (&out->connect_time), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_first_byte_time_set ? 0 : 1;
    if (omit == 0) {
        *length += (15 + 3); // "first_byte_time": 
        get_json_length_upstream_list_peerDef_first_byte_time(pool, (&out->first_byte_time), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_responses_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->responses) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "responses": 
        get_json_length_upstream_list_peerDef_responses(pool, (out->responses), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_sent_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "sent": 
        get_json_length_upstream_list_peerDef_sent(pool, (&out->sent), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_received_set ? 0 : 1;
    if (omit == 0) {
        *length += (8 + 3); // "received": 
        get_json_length_upstream_list_peerDef_received(pool, (&out->received), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "fails": 
        get_json_length_upstream_list_peerDef_fails(pool, (&out->fails), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_unavail_set ? 0 : 1;
    if (omit == 0) {
        *length += (7 + 3); // "unavail": 
        get_json_length_upstream_list_peerDef_unavail(pool, (&out->unavail), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_health_checks_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->health_checks) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (13 + 3); // "health_checks": 
        get_json_length_upstream_list_peerDef_health_checks(pool, (out->health_checks), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_downtime_set ? 0 : 1;
    if (omit == 0) {
        *length += (8 + 3); // "downtime": 
        get_json_length_upstream_list_peerDef_downtime(pool, (&out->downtime), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_downstart_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->downstart.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "downstart": 
        get_json_length_upstream_list_peerDef_downstart(pool, (&out->downstart), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_selected_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->selected.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (8 + 3); // "selected": 
        get_json_length_upstream_list_peerDef_selected(pool, (&out->selected), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_header_time_set ? 0 : 1;
    if (omit == 0) {
        *length += (11 + 3); // "header_time": 
        get_json_length_upstream_list_peerDef_header_time(pool, (&out->header_time), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_response_time_set ? 0 : 1;
    if (omit == 0) {
        *length += (13 + 3); // "response_time": 
        get_json_length_upstream_list_peerDef_response_time(pool, (&out->response_time), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

upstream_list_peerDef_responses_one_t get_upstream_list_peerDef_responses_one(upstream_list_peerDef_responses_t *out) {
    return out->one;
}

upstream_list_peerDef_responses_two_t get_upstream_list_peerDef_responses_two(upstream_list_peerDef_responses_t *out) {
    return out->two;
}

upstream_list_peerDef_responses_three_t get_upstream_list_peerDef_responses_three(upstream_list_peerDef_responses_t *out) {
    return out->three;
}

upstream_list_peerDef_responses_four_t get_upstream_list_peerDef_responses_four(upstream_list_peerDef_responses_t *out) {
    return out->four;
}

upstream_list_peerDef_responses_five_t get_upstream_list_peerDef_responses_five(upstream_list_peerDef_responses_t *out) {
    return out->five;
}

upstream_list_peerDef_responses_codes_t* get_upstream_list_peerDef_responses_codes(upstream_list_peerDef_responses_t *out) {
    return &out->codes;
}

upstream_list_peerDef_responses_total_t get_upstream_list_peerDef_responses_total(upstream_list_peerDef_responses_t *out) {
    return out->total;
}

upstream_list_peerDef_health_checks_checks_t get_upstream_list_peerDef_health_checks_checks(upstream_list_peerDef_health_checks_t *out) {
    return out->checks;
}

upstream_list_peerDef_health_checks_fails_t get_upstream_list_peerDef_health_checks_fails(upstream_list_peerDef_health_checks_t *out) {
    return out->fails;
}

upstream_list_peerDef_health_checks_unhealthy_t get_upstream_list_peerDef_health_checks_unhealthy(upstream_list_peerDef_health_checks_t *out) {
    return out->unhealthy;
}

upstream_list_peerDef_health_checks_last_passed_t get_upstream_list_peerDef_health_checks_last_passed(upstream_list_peerDef_health_checks_t *out) {
    return out->last_passed;
}

upstream_list_peerDef_id_t get_upstream_list_peerDef_id(upstream_list_peerDef_t *out) {
    return out->id;
}

upstream_list_peerDef_server_t* get_upstream_list_peerDef_server(upstream_list_peerDef_t *out) {
    return &out->server;
}

upstream_list_peerDef_name_t* get_upstream_list_peerDef_name(upstream_list_peerDef_t *out) {
    return &out->name;
}

upstream_list_peerDef_backup_t get_upstream_list_peerDef_backup(upstream_list_peerDef_t *out) {
    return out->backup;
}

upstream_list_peerDef_weight_t get_upstream_list_peerDef_weight(upstream_list_peerDef_t *out) {
    return out->weight;
}

upstream_list_peerDef_state_t* get_upstream_list_peerDef_state(upstream_list_peerDef_t *out) {
    return &out->state;
}

upstream_list_peerDef_active_t get_upstream_list_peerDef_active(upstream_list_peerDef_t *out) {
    return out->active;
}

upstream_list_peerDef_max_conns_t get_upstream_list_peerDef_max_conns(upstream_list_peerDef_t *out) {
    return out->max_conns;
}

upstream_list_peerDef_requests_t get_upstream_list_peerDef_requests(upstream_list_peerDef_t *out) {
    return out->requests;
}

upstream_list_peerDef_connections_t get_upstream_list_peerDef_connections(upstream_list_peerDef_t *out) {
    return out->connections;
}

upstream_list_peerDef_connect_time_t get_upstream_list_peerDef_connect_time(upstream_list_peerDef_t *out) {
    return out->connect_time;
}

upstream_list_peerDef_first_byte_time_t get_upstream_list_peerDef_first_byte_time(upstream_list_peerDef_t *out) {
    return out->first_byte_time;
}

upstream_list_peerDef_responses_t* get_upstream_list_peerDef_responses(upstream_list_peerDef_t *out) {
    return out->responses;
}

upstream_list_peerDef_sent_t get_upstream_list_peerDef_sent(upstream_list_peerDef_t *out) {
    return out->sent;
}

upstream_list_peerDef_received_t get_upstream_list_peerDef_received(upstream_list_peerDef_t *out) {
    return out->received;
}

upstream_list_peerDef_fails_t get_upstream_list_peerDef_fails(upstream_list_peerDef_t *out) {
    return out->fails;
}

upstream_list_peerDef_unavail_t get_upstream_list_peerDef_unavail(upstream_list_peerDef_t *out) {
    return out->unavail;
}

upstream_list_peerDef_health_checks_t* get_upstream_list_peerDef_health_checks(upstream_list_peerDef_t *out) {
    return out->health_checks;
}

upstream_list_peerDef_downtime_t get_upstream_list_peerDef_downtime(upstream_list_peerDef_t *out) {
    return out->downtime;
}

upstream_list_peerDef_downstart_t* get_upstream_list_peerDef_downstart(upstream_list_peerDef_t *out) {
    return &out->downstart;
}

upstream_list_peerDef_selected_t* get_upstream_list_peerDef_selected(upstream_list_peerDef_t *out) {
    return &out->selected;
}

upstream_list_peerDef_header_time_t get_upstream_list_peerDef_header_time(upstream_list_peerDef_t *out) {
    return out->header_time;
}

upstream_list_peerDef_response_time_t get_upstream_list_peerDef_response_time(upstream_list_peerDef_t *out) {
    return out->response_time;
}
void set_upstream_list_peerDef_id(upstream_list_peerDef_t* obj, upstream_list_peerDef_id_t field) {
    obj->id = field;
    obj->is_id_set = 1;
}
void set_upstream_list_peerDef_server(upstream_list_peerDef_t* obj, upstream_list_peerDef_server_t* field) {
    njt_memcpy(&obj->server, field, sizeof(njt_str_t));
    obj->is_server_set = 1;
}
void set_upstream_list_peerDef_name(upstream_list_peerDef_t* obj, upstream_list_peerDef_name_t* field) {
    njt_memcpy(&obj->name, field, sizeof(njt_str_t));
    obj->is_name_set = 1;
}
void set_upstream_list_peerDef_backup(upstream_list_peerDef_t* obj, upstream_list_peerDef_backup_t field) {
    obj->backup = field;
    obj->is_backup_set = 1;
}
void set_upstream_list_peerDef_weight(upstream_list_peerDef_t* obj, upstream_list_peerDef_weight_t field) {
    obj->weight = field;
    obj->is_weight_set = 1;
}
void set_upstream_list_peerDef_state(upstream_list_peerDef_t* obj, upstream_list_peerDef_state_t* field) {
    njt_memcpy(&obj->state, field, sizeof(njt_str_t));
    obj->is_state_set = 1;
}
void set_upstream_list_peerDef_active(upstream_list_peerDef_t* obj, upstream_list_peerDef_active_t field) {
    obj->active = field;
    obj->is_active_set = 1;
}
void set_upstream_list_peerDef_max_conns(upstream_list_peerDef_t* obj, upstream_list_peerDef_max_conns_t field) {
    obj->max_conns = field;
    obj->is_max_conns_set = 1;
}
void set_upstream_list_peerDef_requests(upstream_list_peerDef_t* obj, upstream_list_peerDef_requests_t field) {
    obj->requests = field;
    obj->is_requests_set = 1;
}
void set_upstream_list_peerDef_connections(upstream_list_peerDef_t* obj, upstream_list_peerDef_connections_t field) {
    obj->connections = field;
    obj->is_connections_set = 1;
}
void set_upstream_list_peerDef_connect_time(upstream_list_peerDef_t* obj, upstream_list_peerDef_connect_time_t field) {
    obj->connect_time = field;
    obj->is_connect_time_set = 1;
}
void set_upstream_list_peerDef_first_byte_time(upstream_list_peerDef_t* obj, upstream_list_peerDef_first_byte_time_t field) {
    obj->first_byte_time = field;
    obj->is_first_byte_time_set = 1;
}
void set_upstream_list_peerDef_responses_one(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_one_t field) {
    obj->one = field;
    obj->is_one_set = 1;
}
void set_upstream_list_peerDef_responses_two(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_two_t field) {
    obj->two = field;
    obj->is_two_set = 1;
}
void set_upstream_list_peerDef_responses_three(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_three_t field) {
    obj->three = field;
    obj->is_three_set = 1;
}
void set_upstream_list_peerDef_responses_four(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_four_t field) {
    obj->four = field;
    obj->is_four_set = 1;
}
void set_upstream_list_peerDef_responses_five(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_five_t field) {
    obj->five = field;
    obj->is_five_set = 1;
}
void set_upstream_list_peerDef_responses_codes(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_codes_t* field) {
    njt_memcpy(&obj->codes, field, sizeof(njt_str_t));
    obj->is_codes_set = 1;
}
void set_upstream_list_peerDef_responses_total(upstream_list_peerDef_responses_t* obj, upstream_list_peerDef_responses_total_t field) {
    obj->total = field;
    obj->is_total_set = 1;
}
upstream_list_peerDef_responses_t* create_upstream_list_peerDef_responses(njt_pool_t *pool) {
    upstream_list_peerDef_responses_t* out = njt_pcalloc(pool, sizeof(upstream_list_peerDef_responses_t));
    return out;
}
void set_upstream_list_peerDef_responses(upstream_list_peerDef_t* obj, upstream_list_peerDef_responses_t* field) {
    obj->responses = field;
    obj->is_responses_set = 1;
}
void set_upstream_list_peerDef_sent(upstream_list_peerDef_t* obj, upstream_list_peerDef_sent_t field) {
    obj->sent = field;
    obj->is_sent_set = 1;
}
void set_upstream_list_peerDef_received(upstream_list_peerDef_t* obj, upstream_list_peerDef_received_t field) {
    obj->received = field;
    obj->is_received_set = 1;
}
void set_upstream_list_peerDef_fails(upstream_list_peerDef_t* obj, upstream_list_peerDef_fails_t field) {
    obj->fails = field;
    obj->is_fails_set = 1;
}
void set_upstream_list_peerDef_unavail(upstream_list_peerDef_t* obj, upstream_list_peerDef_unavail_t field) {
    obj->unavail = field;
    obj->is_unavail_set = 1;
}
void set_upstream_list_peerDef_health_checks_checks(upstream_list_peerDef_health_checks_t* obj, upstream_list_peerDef_health_checks_checks_t field) {
    obj->checks = field;
    obj->is_checks_set = 1;
}
void set_upstream_list_peerDef_health_checks_fails(upstream_list_peerDef_health_checks_t* obj, upstream_list_peerDef_health_checks_fails_t field) {
    obj->fails = field;
    obj->is_fails_set = 1;
}
void set_upstream_list_peerDef_health_checks_unhealthy(upstream_list_peerDef_health_checks_t* obj, upstream_list_peerDef_health_checks_unhealthy_t field) {
    obj->unhealthy = field;
    obj->is_unhealthy_set = 1;
}
void set_upstream_list_peerDef_health_checks_last_passed(upstream_list_peerDef_health_checks_t* obj, upstream_list_peerDef_health_checks_last_passed_t field) {
    obj->last_passed = field;
    obj->is_last_passed_set = 1;
}
upstream_list_peerDef_health_checks_t* create_upstream_list_peerDef_health_checks(njt_pool_t *pool) {
    upstream_list_peerDef_health_checks_t* out = njt_pcalloc(pool, sizeof(upstream_list_peerDef_health_checks_t));
    return out;
}
void set_upstream_list_peerDef_health_checks(upstream_list_peerDef_t* obj, upstream_list_peerDef_health_checks_t* field) {
    obj->health_checks = field;
    obj->is_health_checks_set = 1;
}
void set_upstream_list_peerDef_downtime(upstream_list_peerDef_t* obj, upstream_list_peerDef_downtime_t field) {
    obj->downtime = field;
    obj->is_downtime_set = 1;
}
void set_upstream_list_peerDef_downstart(upstream_list_peerDef_t* obj, upstream_list_peerDef_downstart_t* field) {
    njt_memcpy(&obj->downstart, field, sizeof(njt_str_t));
    obj->is_downstart_set = 1;
}
void set_upstream_list_peerDef_selected(upstream_list_peerDef_t* obj, upstream_list_peerDef_selected_t* field) {
    njt_memcpy(&obj->selected, field, sizeof(njt_str_t));
    obj->is_selected_set = 1;
}
void set_upstream_list_peerDef_header_time(upstream_list_peerDef_t* obj, upstream_list_peerDef_header_time_t field) {
    obj->header_time = field;
    obj->is_header_time_set = 1;
}
void set_upstream_list_peerDef_response_time(upstream_list_peerDef_t* obj, upstream_list_peerDef_response_time_t field) {
    obj->response_time = field;
    obj->is_response_time_set = 1;
}
upstream_list_peerDef_t* create_upstream_list_peerDef(njt_pool_t *pool) {
    upstream_list_peerDef_t* out = njt_pcalloc(pool, sizeof(upstream_list_peerDef_t));
    return out;
}

static void to_oneline_json_upstream_list_peerDef_id(njt_pool_t *pool, upstream_list_peerDef_id_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_server(njt_pool_t *pool, upstream_list_peerDef_server_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_name(njt_pool_t *pool, upstream_list_peerDef_name_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_backup(njt_pool_t *pool, upstream_list_peerDef_backup_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_upstream_list_peerDef_weight(njt_pool_t *pool, upstream_list_peerDef_weight_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_state(njt_pool_t *pool, upstream_list_peerDef_state_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_active(njt_pool_t *pool, upstream_list_peerDef_active_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_max_conns(njt_pool_t *pool, upstream_list_peerDef_max_conns_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_requests(njt_pool_t *pool, upstream_list_peerDef_requests_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_connections(njt_pool_t *pool, upstream_list_peerDef_connections_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_connect_time(njt_pool_t *pool, upstream_list_peerDef_connect_time_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_first_byte_time(njt_pool_t *pool, upstream_list_peerDef_first_byte_time_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_one(njt_pool_t *pool, upstream_list_peerDef_responses_one_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_two(njt_pool_t *pool, upstream_list_peerDef_responses_two_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_three(njt_pool_t *pool, upstream_list_peerDef_responses_three_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_four(njt_pool_t *pool, upstream_list_peerDef_responses_four_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_five(njt_pool_t *pool, upstream_list_peerDef_responses_five_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_codes(njt_pool_t *pool, upstream_list_peerDef_responses_codes_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses_total(njt_pool_t *pool, upstream_list_peerDef_responses_total_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_responses(njt_pool_t *pool, upstream_list_peerDef_responses_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_one_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"one\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_one(pool, (&out->one), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_two_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"two\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_two(pool, (&out->two), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_three_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"three\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_three(pool, (&out->three), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_four_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"four\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_four(pool, (&out->four), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_five_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"five\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_five(pool, (&out->five), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_codes_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->codes.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"codes\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_codes(pool, (&out->codes), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_total_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"total\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses_total(pool, (&out->total), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_upstream_list_peerDef_sent(njt_pool_t *pool, upstream_list_peerDef_sent_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_received(njt_pool_t *pool, upstream_list_peerDef_received_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_fails(njt_pool_t *pool, upstream_list_peerDef_fails_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_unavail(njt_pool_t *pool, upstream_list_peerDef_unavail_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_health_checks_checks(njt_pool_t *pool, upstream_list_peerDef_health_checks_checks_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_health_checks_fails(njt_pool_t *pool, upstream_list_peerDef_health_checks_fails_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_health_checks_unhealthy(njt_pool_t *pool, upstream_list_peerDef_health_checks_unhealthy_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_health_checks_last_passed(njt_pool_t *pool, upstream_list_peerDef_health_checks_last_passed_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_upstream_list_peerDef_health_checks(njt_pool_t *pool, upstream_list_peerDef_health_checks_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_checks_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"checks\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_health_checks_checks(pool, (&out->checks), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"fails\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_health_checks_fails(pool, (&out->fails), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_unhealthy_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"unhealthy\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_health_checks_unhealthy(pool, (&out->unhealthy), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_last_passed_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"last_passed\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_health_checks_last_passed(pool, (&out->last_passed), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_upstream_list_peerDef_downtime(njt_pool_t *pool, upstream_list_peerDef_downtime_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_downstart(njt_pool_t *pool, upstream_list_peerDef_downstart_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_selected(njt_pool_t *pool, upstream_list_peerDef_selected_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_header_time(njt_pool_t *pool, upstream_list_peerDef_header_time_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef_response_time(njt_pool_t *pool, upstream_list_peerDef_response_time_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_peerDef(njt_pool_t *pool, upstream_list_peerDef_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_id_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"id\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_id(pool, (&out->id), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_server_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->server.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"server\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_server(pool, (&out->server), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"name\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_name(pool, (&out->name), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_backup_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"backup\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_backup(pool, (&out->backup), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_weight_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"weight\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_weight(pool, (&out->weight), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_state_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->state.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"state\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_state(pool, (&out->state), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_active_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"active\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_active(pool, (&out->active), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_max_conns_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"max_conns\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_max_conns(pool, (&out->max_conns), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_requests_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"requests\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_requests(pool, (&out->requests), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_connections_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"connections\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_connections(pool, (&out->connections), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_connect_time_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"connect_time\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_connect_time(pool, (&out->connect_time), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_first_byte_time_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"first_byte_time\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_first_byte_time(pool, (&out->first_byte_time), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_responses_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->responses) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"responses\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_responses(pool, (out->responses), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_sent_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"sent\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_sent(pool, (&out->sent), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_received_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"received\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_received(pool, (&out->received), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"fails\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_fails(pool, (&out->fails), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_unavail_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"unavail\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_unavail(pool, (&out->unavail), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_health_checks_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->health_checks) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"health_checks\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_health_checks(pool, (out->health_checks), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_downtime_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"downtime\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_downtime(pool, (&out->downtime), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_downstart_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->downstart.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"downstart\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_downstart(pool, (&out->downstart), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_selected_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->selected.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"selected\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_selected(pool, (&out->selected), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_header_time_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"header_time\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_header_time(pool, (&out->header_time), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_response_time_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"response_time\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_peerDef_response_time(pool, (&out->response_time), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
static bool parse_upstream_list_upstreamDef(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_upstreamDef_t *out, js2c_parse_error_t *err_ret); //forward decl for public definition
 void get_json_length_upstream_list_upstreamDef(njt_pool_t *pool, upstream_list_upstreamDef_t *out, size_t *length, njt_int_t flags); //forward decl for public definition
 void to_oneline_json_upstream_list_upstreamDef(njt_pool_t *pool, upstream_list_upstreamDef_t *out, njt_str_t *buf, njt_int_t flags); //forward decl for public definition

static bool parse_upstream_list_upstreamDef_peers(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_upstreamDef_peers_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(upstream_list_peerDef_t));
        memset(((upstream_list_upstreamDef_peers_item_t**)out->elts)[i], 0, sizeof(upstream_list_upstreamDef_peers_item_t));
        if (parse_upstream_list_peerDef(pool, parse_state, ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_upstream_list_upstreamDef(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_upstreamDef_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "name")) {
            js2c_check_field_set(out->is_name_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "name";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->name))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->name))->data);
            ((&out->name))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->name), 0, ((&out->name))->len, err_ret)) {
                return true;
            }
            out->is_name_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "peers")) {
            js2c_check_field_set(out->is_peers_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "peers";
            out->peers = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(upstream_list_upstreamDef_peers_item_t*));
            js2c_malloc_check(out->peers);

            if (parse_upstream_list_upstreamDef_peers(pool, parse_state, (out->peers), err_ret)) {
                return true;
            }
            out->is_peers_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "keepalive")) {
            js2c_check_field_set(out->is_keepalive_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "keepalive";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->keepalive) = int_parse_tmp;
            out->is_keepalive_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "zombies")) {
            js2c_check_field_set(out->is_zombies_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "zombies";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->zombies) = int_parse_tmp;
            out->is_zombies_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "zone")) {
            js2c_check_field_set(out->is_zone_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "zone";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->zone))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->zone))->data);
            ((&out->zone))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->zone), 0, ((&out->zone))->len, err_ret)) {
                return true;
            }
            out->is_zone_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_peers_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': peers", parse_state->current_key);
        return true;
    }
    // set default
    if (!out->is_zombies_set) {
        out->zombies = 0LL;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_upstream_list_upstreamDef_name(njt_pool_t *pool, upstream_list_upstreamDef_name_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_upstream_list_upstreamDef_peers_item(njt_pool_t *pool, upstream_list_upstreamDef_peers_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_upstream_list_peerDef(pool, out, length, flags);
}

static void get_json_length_upstream_list_upstreamDef_peers(njt_pool_t *pool, upstream_list_upstreamDef_peers_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_upstream_list_upstreamDef_peers_item(pool, ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_upstream_list_upstreamDef_keepalive(njt_pool_t *pool, upstream_list_upstreamDef_keepalive_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_upstreamDef_zombies(njt_pool_t *pool, upstream_list_upstreamDef_zombies_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_upstream_list_upstreamDef_zone(njt_pool_t *pool, upstream_list_upstreamDef_zone_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

 void get_json_length_upstream_list_upstreamDef(njt_pool_t *pool, upstream_list_upstreamDef_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "name": 
        get_json_length_upstream_list_upstreamDef_name(pool, (&out->name), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_peers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->peers) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (5 + 3); // "peers": 
        get_json_length_upstream_list_upstreamDef_peers(pool, (out->peers), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_keepalive_set ? 0 : 1;
    if (omit == 0) {
        *length += (9 + 3); // "keepalive": 
        get_json_length_upstream_list_upstreamDef_keepalive(pool, (&out->keepalive), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_zombies_set ? 0 : 1;
    if (omit == 0) {
        *length += (7 + 3); // "zombies": 
        get_json_length_upstream_list_upstreamDef_zombies(pool, (&out->zombies), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "zone": 
        get_json_length_upstream_list_upstreamDef_zone(pool, (&out->zone), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}
upstream_list_upstreamDef_peers_item_t* get_upstream_list_upstreamDef_peers_item(upstream_list_upstreamDef_peers_t *out, size_t idx) {
    return ((upstream_list_upstreamDef_peers_item_t**)out->elts)[idx];

}

upstream_list_upstreamDef_name_t* get_upstream_list_upstreamDef_name(upstream_list_upstreamDef_t *out) {
    return &out->name;
}

upstream_list_upstreamDef_peers_t* get_upstream_list_upstreamDef_peers(upstream_list_upstreamDef_t *out) {
    return out->peers;
}

upstream_list_upstreamDef_keepalive_t get_upstream_list_upstreamDef_keepalive(upstream_list_upstreamDef_t *out) {
    return out->keepalive;
}

upstream_list_upstreamDef_zombies_t get_upstream_list_upstreamDef_zombies(upstream_list_upstreamDef_t *out) {
    return out->zombies;
}

upstream_list_upstreamDef_zone_t* get_upstream_list_upstreamDef_zone(upstream_list_upstreamDef_t *out) {
    return &out->zone;
}
void set_upstream_list_upstreamDef_name(upstream_list_upstreamDef_t* obj, upstream_list_upstreamDef_name_t* field) {
    njt_memcpy(&obj->name, field, sizeof(njt_str_t));
    obj->is_name_set = 1;
}
int add_item_upstream_list_upstreamDef_peers(upstream_list_upstreamDef_peers_t *src, upstream_list_upstreamDef_peers_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

upstream_list_upstreamDef_peers_t* create_upstream_list_upstreamDef_peers(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(upstream_list_upstreamDef_peers_item_t*));
}
void set_upstream_list_upstreamDef_peers(upstream_list_upstreamDef_t* obj, upstream_list_upstreamDef_peers_t* field) {
    obj->peers = field;
    obj->is_peers_set = 1;
}
void set_upstream_list_upstreamDef_keepalive(upstream_list_upstreamDef_t* obj, upstream_list_upstreamDef_keepalive_t field) {
    obj->keepalive = field;
    obj->is_keepalive_set = 1;
}
void set_upstream_list_upstreamDef_zombies(upstream_list_upstreamDef_t* obj, upstream_list_upstreamDef_zombies_t field) {
    obj->zombies = field;
    obj->is_zombies_set = 1;
}
void set_upstream_list_upstreamDef_zone(upstream_list_upstreamDef_t* obj, upstream_list_upstreamDef_zone_t* field) {
    njt_memcpy(&obj->zone, field, sizeof(njt_str_t));
    obj->is_zone_set = 1;
}
upstream_list_upstreamDef_t* create_upstream_list_upstreamDef(njt_pool_t *pool) {
    upstream_list_upstreamDef_t* out = njt_pcalloc(pool, sizeof(upstream_list_upstreamDef_t));
    return out;
}

static void to_oneline_json_upstream_list_upstreamDef_name(njt_pool_t *pool, upstream_list_upstreamDef_name_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}
// to_oneline_json_REF

static void to_oneline_json_upstream_list_upstreamDef_peers_item(njt_pool_t *pool, upstream_list_upstreamDef_peers_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_upstream_list_peerDef(pool, out, buf, flags);
}

static void to_oneline_json_upstream_list_upstreamDef_peers(njt_pool_t *pool, upstream_list_upstreamDef_peers_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_upstream_list_upstreamDef_peers_item(pool, ((upstream_list_upstreamDef_peers_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_upstream_list_upstreamDef_keepalive(njt_pool_t *pool, upstream_list_upstreamDef_keepalive_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_upstreamDef_zombies(njt_pool_t *pool, upstream_list_upstreamDef_zombies_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_upstream_list_upstreamDef_zone(njt_pool_t *pool, upstream_list_upstreamDef_zone_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

 void to_oneline_json_upstream_list_upstreamDef(njt_pool_t *pool, upstream_list_upstreamDef_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"name\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_upstreamDef_name(pool, (&out->name), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_peers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->peers) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"peers\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_upstreamDef_peers(pool, (out->peers), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_keepalive_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"keepalive\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_upstreamDef_keepalive(pool, (&out->keepalive), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_zombies_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"zombies\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_upstreamDef_zombies(pool, (&out->zombies), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_zone_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->zone.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"zone\":");
        buf->len = cur - buf->data;
        to_oneline_json_upstream_list_upstreamDef_zone(pool, (&out->zone), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static bool parse_upstream_list(njt_pool_t *pool, parse_state_t *parse_state, upstream_list_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        ((upstream_list_item_t**)out->elts)[i] = njt_pcalloc(pool, sizeof(upstream_list_upstreamDef_t));
        memset(((upstream_list_item_t**)out->elts)[i], 0, sizeof(upstream_list_item_t));
        if (parse_upstream_list_upstreamDef(pool, parse_state, ((upstream_list_item_t**)out->elts)[i], err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static void get_json_length_upstream_list_item(njt_pool_t *pool, upstream_list_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_upstream_list_upstreamDef(pool, out, length, flags);
}

static void get_json_length_upstream_list(njt_pool_t *pool, upstream_list_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((upstream_list_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_upstream_list_item(pool, ((upstream_list_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
upstream_list_item_t* get_upstream_list_item(upstream_list_t *out, size_t idx) {
    return ((upstream_list_item_t**)out->elts)[idx];

}
int add_item_upstream_list(upstream_list_t *src, upstream_list_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

upstream_list_t* create_upstream_list(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(upstream_list_item_t*));
}
// to_oneline_json_REF

static void to_oneline_json_upstream_list_item(njt_pool_t *pool, upstream_list_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_upstream_list_upstreamDef(pool, out, buf, flags);
}

static void to_oneline_json_upstream_list(njt_pool_t *pool, upstream_list_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_OBJ) && ((upstream_list_item_t**)out->elts)[i] == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_upstream_list_item(pool, ((upstream_list_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}
upstream_list_t* json_parse_upstream_list(njt_pool_t *pool, const njt_str_t *json_string, js2c_parse_error_t *err_ret) {
    upstream_list_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_pcalloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_ret);
        if (parse_result == JSMN_ERROR_INVAL) {
            LOG_ERROR_JSON_PARSE(INVALID_JSON_CHAR_ERR, "", -1, "%s", "Invalid character inside JSON string");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_PART) {
            LOG_ERROR_JSON_PARSE(PARTIAL_JSON_ERR, "", -1, "%s", "The string is not a full JSON packet, more bytes expected");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(NULL_JSON_ERR, "", 0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(upstream_list_item_t*));;
    memset(out, 0, sizeof(upstream_list_t));
    if (parse_upstream_list(pool, parse_state, out, err_ret)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_upstream_list(njt_pool_t *pool, upstream_list_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_pcalloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_upstream_list(pool, out, &str_len, flags);
    json_str->data = (u_char*)njt_pcalloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_upstream_list(pool, out, json_str, flags);
    return json_str;
}
