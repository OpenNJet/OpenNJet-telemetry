

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_hc_parser.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */


static bool parse_health_check_stream(njt_pool_t *pool, parse_state_t *parse_state, health_check_stream_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "send")) {
            js2c_check_field_set(out->is_send_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "send";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->send))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->send))->data);
            ((&out->send))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->send), 0, ((&out->send))->len, err_ret)) {
                return true;
            }
            out->is_send_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "expect")) {
            js2c_check_field_set(out->is_expect_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "expect";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->expect))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->expect))->data);
            ((&out->expect))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->expect), 0, ((&out->expect))->len, err_ret)) {
                return true;
            }
            out->is_expect_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_send_set) {
        size_t token_size = strlen("");
        (out->send).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->send).data);
        (out->send).len = token_size;
        if (out->send.len == 0) {
            (out->send).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->send.data, "", token_size);
        }
    }
    // set default
    if (!out->is_expect_set) {
        size_t token_size = strlen("");
        (out->expect).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->expect).data);
        (out->expect).len = token_size;
        if (out->expect.len == 0) {
            (out->expect).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->expect.data, "", token_size);
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check_http_header(njt_pool_t *pool, parse_state_t *parse_state, health_check_http_header_t *out, js2c_parse_error_t *err_ret) {
    int i;
    js2c_check_type(JSMN_ARRAY);
    const int n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((&((health_check_http_header_item_t*)out->elts)[i]))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
        js2c_malloc_check(((&((health_check_http_header_item_t*)out->elts)[i]))->data);
        ((&((health_check_http_header_item_t*)out->elts)[i]))->len = token_size;
        if (builtin_parse_string(pool, parse_state, (&((health_check_http_header_item_t*)out->elts)[i]), 0, ((&((health_check_http_header_item_t*)out->elts)[i]))->len, err_ret)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_health_check_http(njt_pool_t *pool, parse_state_t *parse_state, health_check_http_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "uri")) {
            js2c_check_field_set(out->is_uri_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "uri";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->uri))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->uri))->data);
            ((&out->uri))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->uri), 0, ((&out->uri))->len, err_ret)) {
                return true;
            }
            out->is_uri_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "grpcService")) {
            js2c_check_field_set(out->is_grpcService_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "grpcService";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->grpcService))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->grpcService))->data);
            ((&out->grpcService))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->grpcService), 0, ((&out->grpcService))->len, err_ret)) {
                return true;
            }
            out->is_grpcService_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "grpcStatus")) {
            js2c_check_field_set(out->is_grpcStatus_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "grpcStatus";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->grpcStatus) = int_parse_tmp;
            out->is_grpcStatus_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "header")) {
            js2c_check_field_set(out->is_header_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "header";
            js2c_null_check();
            out->header = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(njt_str_t));
            js2c_malloc_check(out->header);

            if (parse_health_check_http_header(pool, parse_state, (out->header), err_ret)) {
                return true;
            }
            out->is_header_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "body")) {
            js2c_check_field_set(out->is_body_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "body";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->body))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->body))->data);
            ((&out->body))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->body), 0, ((&out->body))->len, err_ret)) {
                return true;
            }
            out->is_body_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "status")) {
            js2c_check_field_set(out->is_status_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "status";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->status))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->status))->data);
            ((&out->status))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->status), 0, ((&out->status))->len, err_ret)) {
                return true;
            }
            out->is_status_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_uri_set) {
        size_t token_size = strlen("");
        (out->uri).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->uri).data);
        (out->uri).len = token_size;
        if (out->uri.len == 0) {
            (out->uri).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->uri.data, "", token_size);
        }
    }
    // set default
    if (!out->is_grpcService_set) {
        size_t token_size = strlen("");
        (out->grpcService).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->grpcService).data);
        (out->grpcService).len = token_size;
        if (out->grpcService.len == 0) {
            (out->grpcService).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->grpcService.data, "", token_size);
        }
    }
    // set default
    if (!out->is_grpcStatus_set) {
        out->grpcStatus = 0LL;
    }
    // set default
    if (!out->is_header_set) {
        out->header = njt_pcalloc(pool, sizeof(njt_array_t));
    }
    // set default
    if (!out->is_body_set) {
        size_t token_size = strlen("");
        (out->body).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->body).data);
        (out->body).len = token_size;
        if (out->body.len == 0) {
            (out->body).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->body.data, "", token_size);
        }
    }
    // set default
    if (!out->is_status_set) {
        size_t token_size = strlen("");
        (out->status).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->status).data);
        (out->status).len = token_size;
        if (out->status.len == 0) {
            (out->status).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->status.data, "", token_size);
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check_ssl(njt_pool_t *pool, parse_state_t *parse_state, health_check_ssl_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "enable")) {
            js2c_check_field_set(out->is_enable_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "enable";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->enable), err_ret)) {
                return true;
            }
            out->is_enable_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ntls")) {
            js2c_check_field_set(out->is_ntls_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ntls";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->ntls), err_ret)) {
                return true;
            }
            out->is_ntls_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "session_reuse")) {
            js2c_check_field_set(out->is_session_reuse_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "session_reuse";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->session_reuse), err_ret)) {
                return true;
            }
            out->is_session_reuse_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "name")) {
            js2c_check_field_set(out->is_name_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "name";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->name))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->name))->data);
            ((&out->name))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->name), 0, ((&out->name))->len, err_ret)) {
                return true;
            }
            out->is_name_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "protocols")) {
            js2c_check_field_set(out->is_protocols_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "protocols";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->protocols))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->protocols))->data);
            ((&out->protocols))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->protocols), 0, ((&out->protocols))->len, err_ret)) {
                return true;
            }
            out->is_protocols_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "serverName")) {
            js2c_check_field_set(out->is_serverName_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "serverName";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->serverName), err_ret)) {
                return true;
            }
            out->is_serverName_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "verify")) {
            js2c_check_field_set(out->is_verify_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "verify";
            js2c_null_check();
            if (builtin_parse_bool(pool, parse_state, (&out->verify), err_ret)) {
                return true;
            }
            out->is_verify_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "verifyDepth")) {
            js2c_check_field_set(out->is_verifyDepth_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "verifyDepth";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(0LL);
            *(&out->verifyDepth) = int_parse_tmp;
            out->is_verifyDepth_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "trustedCertificate")) {
            js2c_check_field_set(out->is_trustedCertificate_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "trustedCertificate";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->trustedCertificate))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->trustedCertificate))->data);
            ((&out->trustedCertificate))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->trustedCertificate), 0, ((&out->trustedCertificate))->len, err_ret)) {
                return true;
            }
            out->is_trustedCertificate_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "crl")) {
            js2c_check_field_set(out->is_crl_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "crl";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->crl))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->crl))->data);
            ((&out->crl))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->crl), 0, ((&out->crl))->len, err_ret)) {
                return true;
            }
            out->is_crl_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "certificate")) {
            js2c_check_field_set(out->is_certificate_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "certificate";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->certificate))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->certificate))->data);
            ((&out->certificate))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->certificate), 0, ((&out->certificate))->len, err_ret)) {
                return true;
            }
            out->is_certificate_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "certificateKey")) {
            js2c_check_field_set(out->is_certificateKey_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "certificateKey";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->certificateKey))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->certificateKey))->data);
            ((&out->certificateKey))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->certificateKey), 0, ((&out->certificateKey))->len, err_ret)) {
                return true;
            }
            out->is_certificateKey_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "encCertificate")) {
            js2c_check_field_set(out->is_encCertificate_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "encCertificate";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->encCertificate))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->encCertificate))->data);
            ((&out->encCertificate))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->encCertificate), 0, ((&out->encCertificate))->len, err_ret)) {
                return true;
            }
            out->is_encCertificate_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "encCertificateKey")) {
            js2c_check_field_set(out->is_encCertificateKey_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "encCertificateKey";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->encCertificateKey))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->encCertificateKey))->data);
            ((&out->encCertificateKey))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->encCertificateKey), 0, ((&out->encCertificateKey))->len, err_ret)) {
                return true;
            }
            out->is_encCertificateKey_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "passwords")) {
            js2c_check_field_set(out->is_passwords_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "passwords";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->passwords))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->passwords))->data);
            ((&out->passwords))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->passwords), 0, ((&out->passwords))->len, err_ret)) {
                return true;
            }
            out->is_passwords_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "conf_commands")) {
            js2c_check_field_set(out->is_conf_commands_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "conf_commands";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->conf_commands))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->conf_commands))->data);
            ((&out->conf_commands))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->conf_commands), 0, ((&out->conf_commands))->len, err_ret)) {
                return true;
            }
            out->is_conf_commands_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ciphers")) {
            js2c_check_field_set(out->is_ciphers_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ciphers";
            js2c_null_check();
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->ciphers))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->ciphers))->data);
            ((&out->ciphers))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->ciphers), 0, ((&out->ciphers))->len, err_ret)) {
                return true;
            }
            out->is_ciphers_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // set default
    if (!out->is_enable_set) {
        out->enable = false;
    }
    // set default
    if (!out->is_ntls_set) {
        out->ntls = false;
    }
    // set default
    if (!out->is_session_reuse_set) {
        out->session_reuse = false;
    }
    // set default
    if (!out->is_name_set) {
        size_t token_size = strlen("");
        (out->name).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->name).data);
        (out->name).len = token_size;
        if (out->name.len == 0) {
            (out->name).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->name.data, "", token_size);
        }
    }
    // set default
    if (!out->is_protocols_set) {
        size_t token_size = strlen("");
        (out->protocols).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->protocols).data);
        (out->protocols).len = token_size;
        if (out->protocols.len == 0) {
            (out->protocols).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->protocols.data, "", token_size);
        }
    }
    // set default
    if (!out->is_serverName_set) {
        out->serverName = false;
    }
    // set default
    if (!out->is_verify_set) {
        out->verify = false;
    }
    // set default
    if (!out->is_verifyDepth_set) {
        out->verifyDepth = 0LL;
    }
    // set default
    if (!out->is_trustedCertificate_set) {
        size_t token_size = strlen("");
        (out->trustedCertificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->trustedCertificate).data);
        (out->trustedCertificate).len = token_size;
        if (out->trustedCertificate.len == 0) {
            (out->trustedCertificate).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->trustedCertificate.data, "", token_size);
        }
    }
    // set default
    if (!out->is_crl_set) {
        size_t token_size = strlen("");
        (out->crl).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->crl).data);
        (out->crl).len = token_size;
        if (out->crl.len == 0) {
            (out->crl).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->crl.data, "", token_size);
        }
    }
    // set default
    if (!out->is_certificate_set) {
        size_t token_size = strlen("");
        (out->certificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->certificate).data);
        (out->certificate).len = token_size;
        if (out->certificate.len == 0) {
            (out->certificate).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->certificate.data, "", token_size);
        }
    }
    // set default
    if (!out->is_certificateKey_set) {
        size_t token_size = strlen("");
        (out->certificateKey).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->certificateKey).data);
        (out->certificateKey).len = token_size;
        if (out->certificateKey.len == 0) {
            (out->certificateKey).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->certificateKey.data, "", token_size);
        }
    }
    // set default
    if (!out->is_encCertificate_set) {
        size_t token_size = strlen("");
        (out->encCertificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->encCertificate).data);
        (out->encCertificate).len = token_size;
        if (out->encCertificate.len == 0) {
            (out->encCertificate).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->encCertificate.data, "", token_size);
        }
    }
    // set default
    if (!out->is_encCertificateKey_set) {
        size_t token_size = strlen("");
        (out->encCertificateKey).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->encCertificateKey).data);
        (out->encCertificateKey).len = token_size;
        if (out->encCertificateKey.len == 0) {
            (out->encCertificateKey).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->encCertificateKey.data, "", token_size);
        }
    }
    // set default
    if (!out->is_passwords_set) {
        size_t token_size = strlen("");
        (out->passwords).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->passwords).data);
        (out->passwords).len = token_size;
        if (out->passwords.len == 0) {
            (out->passwords).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->passwords.data, "", token_size);
        }
    }
    // set default
    if (!out->is_conf_commands_set) {
        size_t token_size = strlen("");
        (out->conf_commands).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->conf_commands).data);
        (out->conf_commands).len = token_size;
        if (out->conf_commands.len == 0) {
            (out->conf_commands).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->conf_commands.data, "", token_size);
        }
    }
    // set default
    if (!out->is_ciphers_set) {
        size_t token_size = strlen("DEFAULT");
        (out->ciphers).data = (u_char*)njt_pcalloc(pool, token_size + 1);
        js2c_malloc_check((out->ciphers).data);
        (out->ciphers).len = token_size;
        if (out->ciphers.len == 0) {
            (out->ciphers).data[0] = 0;
        }
        if (token_size > 0) {
            njt_memcpy(out->ciphers.data, "DEFAULT", token_size);
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check(njt_pool_t *pool, parse_state_t *parse_state, health_check_t *out, js2c_parse_error_t *err_ret) {
    njt_uint_t i;

    js2c_check_type(JSMN_OBJECT);
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        js2c_key_children_check_for_obj();
        if (current_string_is(parse_state, "interval")) {
            js2c_check_field_set(out->is_interval_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "interval";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->interval))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->interval))->data);
            ((&out->interval))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->interval), 0, ((&out->interval))->len, err_ret)) {
                return true;
            }
            out->is_interval_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "jitter")) {
            js2c_check_field_set(out->is_jitter_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "jitter";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->jitter))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->jitter))->data);
            ((&out->jitter))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->jitter), 0, ((&out->jitter))->len, err_ret)) {
                return true;
            }
            out->is_jitter_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "timeout")) {
            js2c_check_field_set(out->is_timeout_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "timeout";
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            ((&out->timeout))->data = (u_char*)njt_pcalloc(pool, (size_t)(token_size + 1));
            js2c_malloc_check(((&out->timeout))->data);
            ((&out->timeout))->len = token_size;
            if (builtin_parse_string(pool, parse_state, (&out->timeout), 0, ((&out->timeout))->len, err_ret)) {
                return true;
            }
            out->is_timeout_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "passes")) {
            js2c_check_field_set(out->is_passes_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "passes";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(1LL);
            *(&out->passes) = int_parse_tmp;
            out->is_passes_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "fails")) {
            js2c_check_field_set(out->is_fails_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "fails";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(1LL);
            *(&out->fails) = int_parse_tmp;
            out->is_fails_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "port")) {
            js2c_check_field_set(out->is_port_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "port";
            js2c_null_check();
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_ret)) {
                return true;
            }
            js2c_int_range_check_min(1LL);
            js2c_int_range_check_max(65535LL);
            *(&out->port) = int_parse_tmp;
            out->is_port_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "stream")) {
            js2c_check_field_set(out->is_stream_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "stream";
            js2c_null_check();
            out->stream = njt_pcalloc(pool, sizeof(health_check_stream_t));
            js2c_malloc_check(out->stream);
            memset(out->stream, 0, sizeof(health_check_stream_t));

            if (parse_health_check_stream(pool, parse_state, (out->stream), err_ret)) {
                return true;
            }
            out->is_stream_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "http")) {
            js2c_check_field_set(out->is_http_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "http";
            js2c_null_check();
            out->http = njt_pcalloc(pool, sizeof(health_check_http_t));
            js2c_malloc_check(out->http);
            memset(out->http, 0, sizeof(health_check_http_t));

            if (parse_health_check_http(pool, parse_state, (out->http), err_ret)) {
                return true;
            }
            out->is_http_set = 1;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ssl")) {
            js2c_check_field_set(out->is_ssl_set);
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ssl";
            js2c_null_check();
            out->ssl = njt_pcalloc(pool, sizeof(health_check_ssl_t));
            js2c_malloc_check(out->ssl);
            memset(out->ssl, 0, sizeof(health_check_ssl_t));

            if (parse_health_check_ssl(pool, parse_state, (out->ssl), err_ret)) {
                return true;
            }
            out->is_ssl_set = 1;
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(UNKNOWN_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state));
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!out->is_interval_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': interval", parse_state->current_key);
        return true;
    }
    if (!out->is_jitter_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': jitter", parse_state->current_key);
        return true;
    }
    if (!out->is_timeout_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': timeout", parse_state->current_key);
        return true;
    }
    if (!out->is_passes_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': passes", parse_state->current_key);
        return true;
    }
    if (!out->is_fails_set) {
        LOG_ERROR_JSON_PARSE(MISSING_REQUIRED_FIELD_ERR, parse_state->current_key, CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': fails", parse_state->current_key);
        return true;
    }
    // set default
    if (!out->is_port_set) {
        out->port = 0LL;
    }
    // set default
    if (!out->is_stream_set) {
        out->stream = njt_pcalloc(pool, sizeof(health_check_stream_t));
        js2c_malloc_check(out->stream);
        memset(out->stream, 0, sizeof(health_check_stream_t));
 {
            size_t token_size = strlen("");
            (out->stream->send).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->stream->send).data);
            (out->stream->send).len = token_size;
            if (out->stream->send.len == 0) {
                (out->stream->send).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->stream->send.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->stream->expect).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->stream->expect).data);
            (out->stream->expect).len = token_size;
            if (out->stream->expect.len == 0) {
                (out->stream->expect).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->stream->expect.data, "", token_size);
            }
        }
    }
    // set default
    if (!out->is_http_set) {
        out->http = njt_pcalloc(pool, sizeof(health_check_http_t));
        js2c_malloc_check(out->http);
        memset(out->http, 0, sizeof(health_check_http_t));
 {
            size_t token_size = strlen("");
            (out->http->uri).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->http->uri).data);
            (out->http->uri).len = token_size;
            if (out->http->uri.len == 0) {
                (out->http->uri).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->http->uri.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->http->grpcService).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->http->grpcService).data);
            (out->http->grpcService).len = token_size;
            if (out->http->grpcService.len == 0) {
                (out->http->grpcService).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->http->grpcService.data, "", token_size);
            }
        }
 {
            out->http->grpcStatus = 0LL;
        }
 {
            out->http->header = njt_pcalloc(pool, sizeof(njt_array_t));
        }
 {
            size_t token_size = strlen("");
            (out->http->body).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->http->body).data);
            (out->http->body).len = token_size;
            if (out->http->body.len == 0) {
                (out->http->body).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->http->body.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->http->status).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->http->status).data);
            (out->http->status).len = token_size;
            if (out->http->status.len == 0) {
                (out->http->status).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->http->status.data, "", token_size);
            }
        }
    }
    // set default
    if (!out->is_ssl_set) {
        out->ssl = njt_pcalloc(pool, sizeof(health_check_ssl_t));
        js2c_malloc_check(out->ssl);
        memset(out->ssl, 0, sizeof(health_check_ssl_t));
 {
            out->ssl->enable = false;
        }
 {
            out->ssl->ntls = false;
        }
 {
            out->ssl->session_reuse = false;
        }
 {
            size_t token_size = strlen("");
            (out->ssl->name).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->name).data);
            (out->ssl->name).len = token_size;
            if (out->ssl->name.len == 0) {
                (out->ssl->name).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->name.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->protocols).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->protocols).data);
            (out->ssl->protocols).len = token_size;
            if (out->ssl->protocols.len == 0) {
                (out->ssl->protocols).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->protocols.data, "", token_size);
            }
        }
 {
            out->ssl->serverName = false;
        }
 {
            out->ssl->verify = false;
        }
 {
            out->ssl->verifyDepth = 0LL;
        }
 {
            size_t token_size = strlen("");
            (out->ssl->trustedCertificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->trustedCertificate).data);
            (out->ssl->trustedCertificate).len = token_size;
            if (out->ssl->trustedCertificate.len == 0) {
                (out->ssl->trustedCertificate).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->trustedCertificate.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->crl).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->crl).data);
            (out->ssl->crl).len = token_size;
            if (out->ssl->crl.len == 0) {
                (out->ssl->crl).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->crl.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->certificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->certificate).data);
            (out->ssl->certificate).len = token_size;
            if (out->ssl->certificate.len == 0) {
                (out->ssl->certificate).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->certificate.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->certificateKey).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->certificateKey).data);
            (out->ssl->certificateKey).len = token_size;
            if (out->ssl->certificateKey.len == 0) {
                (out->ssl->certificateKey).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->certificateKey.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->encCertificate).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->encCertificate).data);
            (out->ssl->encCertificate).len = token_size;
            if (out->ssl->encCertificate.len == 0) {
                (out->ssl->encCertificate).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->encCertificate.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->encCertificateKey).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->encCertificateKey).data);
            (out->ssl->encCertificateKey).len = token_size;
            if (out->ssl->encCertificateKey.len == 0) {
                (out->ssl->encCertificateKey).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->encCertificateKey.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->passwords).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->passwords).data);
            (out->ssl->passwords).len = token_size;
            if (out->ssl->passwords.len == 0) {
                (out->ssl->passwords).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->passwords.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("");
            (out->ssl->conf_commands).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->conf_commands).data);
            (out->ssl->conf_commands).len = token_size;
            if (out->ssl->conf_commands.len == 0) {
                (out->ssl->conf_commands).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->conf_commands.data, "", token_size);
            }
        }
 {
            size_t token_size = strlen("DEFAULT");
            (out->ssl->ciphers).data = (u_char*)njt_pcalloc(pool, token_size + 1);
            js2c_malloc_check((out->ssl->ciphers).data);
            (out->ssl->ciphers).len = token_size;
            if (out->ssl->ciphers.len == 0) {
                (out->ssl->ciphers).data[0] = 0;
            }
            if (token_size > 0) {
                njt_memcpy(out->ssl->ciphers.data, "DEFAULT", token_size);
            }
        }
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_health_check_interval(njt_pool_t *pool, health_check_interval_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_jitter(njt_pool_t *pool, health_check_jitter_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_timeout(njt_pool_t *pool, health_check_timeout_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_passes(njt_pool_t *pool, health_check_passes_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_health_check_fails(njt_pool_t *pool, health_check_fails_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_health_check_port(njt_pool_t *pool, health_check_port_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_health_check_stream_send(njt_pool_t *pool, health_check_stream_send_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_stream_expect(njt_pool_t *pool, health_check_stream_expect_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_stream(njt_pool_t *pool, health_check_stream_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_send_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->send.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "send": 
        get_json_length_health_check_stream_send(pool, (&out->send), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_expect_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->expect.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "expect": 
        get_json_length_health_check_stream_expect(pool, (&out->expect), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check_http_uri(njt_pool_t *pool, health_check_http_uri_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_http_grpcService(njt_pool_t *pool, health_check_http_grpcService_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_http_grpcStatus(njt_pool_t *pool, health_check_http_grpcStatus_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_health_check_http_header_item(njt_pool_t *pool, health_check_http_header_item_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_http_header(njt_pool_t *pool, health_check_http_header_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((health_check_http_header_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            get_json_length_health_check_http_header_item(pool, (&((health_check_http_header_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_health_check_http_body(njt_pool_t *pool, health_check_http_body_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_http_status(njt_pool_t *pool, health_check_http_status_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_http(njt_pool_t *pool, health_check_http_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_uri_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->uri.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (3 + 3); // "uri": 
        get_json_length_health_check_http_uri(pool, (&out->uri), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_grpcService_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->grpcService.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (11 + 3); // "grpcService": 
        get_json_length_health_check_http_grpcService(pool, (&out->grpcService), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_grpcStatus_set ? 0 : 1;
    if (omit == 0) {
        *length += (10 + 3); // "grpcStatus": 
        get_json_length_health_check_http_grpcStatus(pool, (&out->grpcStatus), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_header_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->header) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "header": 
        get_json_length_health_check_http_header(pool, (out->header), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_body_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->body.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "body": 
        get_json_length_health_check_http_body(pool, (&out->body), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_status_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->status.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "status": 
        get_json_length_health_check_http_status(pool, (&out->status), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check_ssl_enable(njt_pool_t *pool, health_check_ssl_enable_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_ntls(njt_pool_t *pool, health_check_ssl_ntls_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_session_reuse(njt_pool_t *pool, health_check_ssl_session_reuse_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_name(njt_pool_t *pool, health_check_ssl_name_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_protocols(njt_pool_t *pool, health_check_ssl_protocols_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_serverName(njt_pool_t *pool, health_check_ssl_serverName_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_verify(njt_pool_t *pool, health_check_ssl_verify_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_verifyDepth(njt_pool_t *pool, health_check_ssl_verifyDepth_t *out, size_t *length, njt_int_t flags) {
    u_char str[24];
    u_char *cur;
    cur = njt_sprintf(str, "%L", *out);
    *length += cur - str;
}

static void get_json_length_health_check_ssl_trustedCertificate(njt_pool_t *pool, health_check_ssl_trustedCertificate_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_crl(njt_pool_t *pool, health_check_ssl_crl_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_certificate(njt_pool_t *pool, health_check_ssl_certificate_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_certificateKey(njt_pool_t *pool, health_check_ssl_certificateKey_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_encCertificate(njt_pool_t *pool, health_check_ssl_encCertificate_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_encCertificateKey(njt_pool_t *pool, health_check_ssl_encCertificateKey_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_passwords(njt_pool_t *pool, health_check_ssl_passwords_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_conf_commands(njt_pool_t *pool, health_check_ssl_conf_commands_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl_ciphers(njt_pool_t *pool, health_check_ssl_ciphers_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl(njt_pool_t *pool, health_check_ssl_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_enable_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "enable": 
        get_json_length_health_check_ssl_enable(pool, (&out->enable), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_ntls_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "ntls": 
        get_json_length_health_check_ssl_ntls(pool, (&out->ntls), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_session_reuse_set ? 0 : 1;
    if (omit == 0) {
        *length += (13 + 3); // "session_reuse": 
        get_json_length_health_check_ssl_session_reuse(pool, (&out->session_reuse), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "name": 
        get_json_length_health_check_ssl_name(pool, (&out->name), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_protocols_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->protocols.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "protocols": 
        get_json_length_health_check_ssl_protocols(pool, (&out->protocols), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_serverName_set ? 0 : 1;
    if (omit == 0) {
        *length += (10 + 3); // "serverName": 
        get_json_length_health_check_ssl_serverName(pool, (&out->serverName), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_verify_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "verify": 
        get_json_length_health_check_ssl_verify(pool, (&out->verify), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_verifyDepth_set ? 0 : 1;
    if (omit == 0) {
        *length += (11 + 3); // "verifyDepth": 
        get_json_length_health_check_ssl_verifyDepth(pool, (&out->verifyDepth), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_trustedCertificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->trustedCertificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (18 + 3); // "trustedCertificate": 
        get_json_length_health_check_ssl_trustedCertificate(pool, (&out->trustedCertificate), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_crl_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->crl.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (3 + 3); // "crl": 
        get_json_length_health_check_ssl_crl(pool, (&out->crl), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_certificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->certificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (11 + 3); // "certificate": 
        get_json_length_health_check_ssl_certificate(pool, (&out->certificate), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_certificateKey_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->certificateKey.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (14 + 3); // "certificateKey": 
        get_json_length_health_check_ssl_certificateKey(pool, (&out->certificateKey), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_encCertificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->encCertificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (14 + 3); // "encCertificate": 
        get_json_length_health_check_ssl_encCertificate(pool, (&out->encCertificate), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_encCertificateKey_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->encCertificateKey.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (17 + 3); // "encCertificateKey": 
        get_json_length_health_check_ssl_encCertificateKey(pool, (&out->encCertificateKey), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_passwords_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->passwords.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (9 + 3); // "passwords": 
        get_json_length_health_check_ssl_passwords(pool, (&out->passwords), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_conf_commands_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->conf_commands.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (13 + 3); // "conf_commands": 
        get_json_length_health_check_ssl_conf_commands(pool, (&out->conf_commands), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_ciphers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->ciphers.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (7 + 3); // "ciphers": 
        get_json_length_health_check_ssl_ciphers(pool, (&out->ciphers), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check(njt_pool_t *pool, health_check_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    omit = out->is_interval_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->interval.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (8 + 3); // "interval": 
        get_json_length_health_check_interval(pool, (&out->interval), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_jitter_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->jitter.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "jitter": 
        get_json_length_health_check_jitter(pool, (&out->jitter), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_timeout_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->timeout.data) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (7 + 3); // "timeout": 
        get_json_length_health_check_timeout(pool, (&out->timeout), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_passes_set ? 0 : 1;
    if (omit == 0) {
        *length += (6 + 3); // "passes": 
        get_json_length_health_check_passes(pool, (&out->passes), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        *length += (5 + 3); // "fails": 
        get_json_length_health_check_fails(pool, (&out->fails), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_port_set ? 0 : 1;
    if (omit == 0) {
        *length += (4 + 3); // "port": 
        get_json_length_health_check_port(pool, (&out->port), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_stream_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->stream) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (6 + 3); // "stream": 
        get_json_length_health_check_stream(pool, (out->stream), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_http_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->http) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (4 + 3); // "http": 
        get_json_length_health_check_http(pool, (out->http), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    omit = out->is_ssl_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->ssl) == NULL ? 1 : omit;
    if (omit == 0) {
        *length += (3 + 3); // "ssl": 
        get_json_length_health_check_ssl(pool, (out->ssl), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

health_check_stream_send_t* get_health_check_stream_send(health_check_stream_t *out) {
    return &out->send;
}

health_check_stream_expect_t* get_health_check_stream_expect(health_check_stream_t *out) {
    return &out->expect;
}
health_check_http_header_item_t* get_health_check_http_header_item(health_check_http_header_t *out, size_t idx) {
    return &((health_check_http_header_item_t*)out->elts)[idx];

}

health_check_http_uri_t* get_health_check_http_uri(health_check_http_t *out) {
    return &out->uri;
}

health_check_http_grpcService_t* get_health_check_http_grpcService(health_check_http_t *out) {
    return &out->grpcService;
}

health_check_http_grpcStatus_t get_health_check_http_grpcStatus(health_check_http_t *out) {
    return out->grpcStatus;
}

health_check_http_header_t* get_health_check_http_header(health_check_http_t *out) {
    return out->header;
}

health_check_http_body_t* get_health_check_http_body(health_check_http_t *out) {
    return &out->body;
}

health_check_http_status_t* get_health_check_http_status(health_check_http_t *out) {
    return &out->status;
}

health_check_ssl_enable_t get_health_check_ssl_enable(health_check_ssl_t *out) {
    return out->enable;
}

health_check_ssl_ntls_t get_health_check_ssl_ntls(health_check_ssl_t *out) {
    return out->ntls;
}

health_check_ssl_session_reuse_t get_health_check_ssl_session_reuse(health_check_ssl_t *out) {
    return out->session_reuse;
}

health_check_ssl_name_t* get_health_check_ssl_name(health_check_ssl_t *out) {
    return &out->name;
}

health_check_ssl_protocols_t* get_health_check_ssl_protocols(health_check_ssl_t *out) {
    return &out->protocols;
}

health_check_ssl_serverName_t get_health_check_ssl_serverName(health_check_ssl_t *out) {
    return out->serverName;
}

health_check_ssl_verify_t get_health_check_ssl_verify(health_check_ssl_t *out) {
    return out->verify;
}

health_check_ssl_verifyDepth_t get_health_check_ssl_verifyDepth(health_check_ssl_t *out) {
    return out->verifyDepth;
}

health_check_ssl_trustedCertificate_t* get_health_check_ssl_trustedCertificate(health_check_ssl_t *out) {
    return &out->trustedCertificate;
}

health_check_ssl_crl_t* get_health_check_ssl_crl(health_check_ssl_t *out) {
    return &out->crl;
}

health_check_ssl_certificate_t* get_health_check_ssl_certificate(health_check_ssl_t *out) {
    return &out->certificate;
}

health_check_ssl_certificateKey_t* get_health_check_ssl_certificateKey(health_check_ssl_t *out) {
    return &out->certificateKey;
}

health_check_ssl_encCertificate_t* get_health_check_ssl_encCertificate(health_check_ssl_t *out) {
    return &out->encCertificate;
}

health_check_ssl_encCertificateKey_t* get_health_check_ssl_encCertificateKey(health_check_ssl_t *out) {
    return &out->encCertificateKey;
}

health_check_ssl_passwords_t* get_health_check_ssl_passwords(health_check_ssl_t *out) {
    return &out->passwords;
}

health_check_ssl_conf_commands_t* get_health_check_ssl_conf_commands(health_check_ssl_t *out) {
    return &out->conf_commands;
}

health_check_ssl_ciphers_t* get_health_check_ssl_ciphers(health_check_ssl_t *out) {
    return &out->ciphers;
}

health_check_interval_t* get_health_check_interval(health_check_t *out) {
    return &out->interval;
}

health_check_jitter_t* get_health_check_jitter(health_check_t *out) {
    return &out->jitter;
}

health_check_timeout_t* get_health_check_timeout(health_check_t *out) {
    return &out->timeout;
}

health_check_passes_t get_health_check_passes(health_check_t *out) {
    return out->passes;
}

health_check_fails_t get_health_check_fails(health_check_t *out) {
    return out->fails;
}

health_check_port_t get_health_check_port(health_check_t *out) {
    return out->port;
}

health_check_stream_t* get_health_check_stream(health_check_t *out) {
    return out->stream;
}

health_check_http_t* get_health_check_http(health_check_t *out) {
    return out->http;
}

health_check_ssl_t* get_health_check_ssl(health_check_t *out) {
    return out->ssl;
}
void set_health_check_interval(health_check_t* obj, health_check_interval_t* field) {
    njt_memcpy(&obj->interval, field, sizeof(njt_str_t));
    obj->is_interval_set = 1;
}
void set_health_check_jitter(health_check_t* obj, health_check_jitter_t* field) {
    njt_memcpy(&obj->jitter, field, sizeof(njt_str_t));
    obj->is_jitter_set = 1;
}
void set_health_check_timeout(health_check_t* obj, health_check_timeout_t* field) {
    njt_memcpy(&obj->timeout, field, sizeof(njt_str_t));
    obj->is_timeout_set = 1;
}
void set_health_check_passes(health_check_t* obj, health_check_passes_t field) {
    obj->passes = field;
    obj->is_passes_set = 1;
}
void set_health_check_fails(health_check_t* obj, health_check_fails_t field) {
    obj->fails = field;
    obj->is_fails_set = 1;
}
void set_health_check_port(health_check_t* obj, health_check_port_t field) {
    obj->port = field;
    obj->is_port_set = 1;
}
void set_health_check_stream_send(health_check_stream_t* obj, health_check_stream_send_t* field) {
    njt_memcpy(&obj->send, field, sizeof(njt_str_t));
    obj->is_send_set = 1;
}
void set_health_check_stream_expect(health_check_stream_t* obj, health_check_stream_expect_t* field) {
    njt_memcpy(&obj->expect, field, sizeof(njt_str_t));
    obj->is_expect_set = 1;
}
health_check_stream_t* create_health_check_stream(njt_pool_t *pool) {
    health_check_stream_t* out = njt_pcalloc(pool, sizeof(health_check_stream_t));
    return out;
}
void set_health_check_stream(health_check_t* obj, health_check_stream_t* field) {
    obj->stream = field;
    obj->is_stream_set = 1;
}
void set_health_check_http_uri(health_check_http_t* obj, health_check_http_uri_t* field) {
    njt_memcpy(&obj->uri, field, sizeof(njt_str_t));
    obj->is_uri_set = 1;
}
void set_health_check_http_grpcService(health_check_http_t* obj, health_check_http_grpcService_t* field) {
    njt_memcpy(&obj->grpcService, field, sizeof(njt_str_t));
    obj->is_grpcService_set = 1;
}
void set_health_check_http_grpcStatus(health_check_http_t* obj, health_check_http_grpcStatus_t field) {
    obj->grpcStatus = field;
    obj->is_grpcStatus_set = 1;
}
int add_item_health_check_http_header(health_check_http_header_t *src, health_check_http_header_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, item, src->size);
    return NJT_OK;
}

health_check_http_header_t* create_health_check_http_header(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(health_check_http_header_item_t));
}
void set_health_check_http_header(health_check_http_t* obj, health_check_http_header_t* field) {
    obj->header = field;
    obj->is_header_set = 1;
}
void set_health_check_http_body(health_check_http_t* obj, health_check_http_body_t* field) {
    njt_memcpy(&obj->body, field, sizeof(njt_str_t));
    obj->is_body_set = 1;
}
void set_health_check_http_status(health_check_http_t* obj, health_check_http_status_t* field) {
    njt_memcpy(&obj->status, field, sizeof(njt_str_t));
    obj->is_status_set = 1;
}
health_check_http_t* create_health_check_http(njt_pool_t *pool) {
    health_check_http_t* out = njt_pcalloc(pool, sizeof(health_check_http_t));
    return out;
}
void set_health_check_http(health_check_t* obj, health_check_http_t* field) {
    obj->http = field;
    obj->is_http_set = 1;
}
void set_health_check_ssl_enable(health_check_ssl_t* obj, health_check_ssl_enable_t field) {
    obj->enable = field;
    obj->is_enable_set = 1;
}
void set_health_check_ssl_ntls(health_check_ssl_t* obj, health_check_ssl_ntls_t field) {
    obj->ntls = field;
    obj->is_ntls_set = 1;
}
void set_health_check_ssl_session_reuse(health_check_ssl_t* obj, health_check_ssl_session_reuse_t field) {
    obj->session_reuse = field;
    obj->is_session_reuse_set = 1;
}
void set_health_check_ssl_name(health_check_ssl_t* obj, health_check_ssl_name_t* field) {
    njt_memcpy(&obj->name, field, sizeof(njt_str_t));
    obj->is_name_set = 1;
}
void set_health_check_ssl_protocols(health_check_ssl_t* obj, health_check_ssl_protocols_t* field) {
    njt_memcpy(&obj->protocols, field, sizeof(njt_str_t));
    obj->is_protocols_set = 1;
}
void set_health_check_ssl_serverName(health_check_ssl_t* obj, health_check_ssl_serverName_t field) {
    obj->serverName = field;
    obj->is_serverName_set = 1;
}
void set_health_check_ssl_verify(health_check_ssl_t* obj, health_check_ssl_verify_t field) {
    obj->verify = field;
    obj->is_verify_set = 1;
}
void set_health_check_ssl_verifyDepth(health_check_ssl_t* obj, health_check_ssl_verifyDepth_t field) {
    obj->verifyDepth = field;
    obj->is_verifyDepth_set = 1;
}
void set_health_check_ssl_trustedCertificate(health_check_ssl_t* obj, health_check_ssl_trustedCertificate_t* field) {
    njt_memcpy(&obj->trustedCertificate, field, sizeof(njt_str_t));
    obj->is_trustedCertificate_set = 1;
}
void set_health_check_ssl_crl(health_check_ssl_t* obj, health_check_ssl_crl_t* field) {
    njt_memcpy(&obj->crl, field, sizeof(njt_str_t));
    obj->is_crl_set = 1;
}
void set_health_check_ssl_certificate(health_check_ssl_t* obj, health_check_ssl_certificate_t* field) {
    njt_memcpy(&obj->certificate, field, sizeof(njt_str_t));
    obj->is_certificate_set = 1;
}
void set_health_check_ssl_certificateKey(health_check_ssl_t* obj, health_check_ssl_certificateKey_t* field) {
    njt_memcpy(&obj->certificateKey, field, sizeof(njt_str_t));
    obj->is_certificateKey_set = 1;
}
void set_health_check_ssl_encCertificate(health_check_ssl_t* obj, health_check_ssl_encCertificate_t* field) {
    njt_memcpy(&obj->encCertificate, field, sizeof(njt_str_t));
    obj->is_encCertificate_set = 1;
}
void set_health_check_ssl_encCertificateKey(health_check_ssl_t* obj, health_check_ssl_encCertificateKey_t* field) {
    njt_memcpy(&obj->encCertificateKey, field, sizeof(njt_str_t));
    obj->is_encCertificateKey_set = 1;
}
void set_health_check_ssl_passwords(health_check_ssl_t* obj, health_check_ssl_passwords_t* field) {
    njt_memcpy(&obj->passwords, field, sizeof(njt_str_t));
    obj->is_passwords_set = 1;
}
void set_health_check_ssl_conf_commands(health_check_ssl_t* obj, health_check_ssl_conf_commands_t* field) {
    njt_memcpy(&obj->conf_commands, field, sizeof(njt_str_t));
    obj->is_conf_commands_set = 1;
}
void set_health_check_ssl_ciphers(health_check_ssl_t* obj, health_check_ssl_ciphers_t* field) {
    njt_memcpy(&obj->ciphers, field, sizeof(njt_str_t));
    obj->is_ciphers_set = 1;
}
health_check_ssl_t* create_health_check_ssl(njt_pool_t *pool) {
    health_check_ssl_t* out = njt_pcalloc(pool, sizeof(health_check_ssl_t));
    return out;
}
void set_health_check_ssl(health_check_t* obj, health_check_ssl_t* field) {
    obj->ssl = field;
    obj->is_ssl_set = 1;
}
health_check_t* create_health_check(njt_pool_t *pool) {
    health_check_t* out = njt_pcalloc(pool, sizeof(health_check_t));
    return out;
}

static void to_oneline_json_health_check_interval(njt_pool_t *pool, health_check_interval_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_jitter(njt_pool_t *pool, health_check_jitter_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_timeout(njt_pool_t *pool, health_check_timeout_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_passes(njt_pool_t *pool, health_check_passes_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_fails(njt_pool_t *pool, health_check_fails_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_port(njt_pool_t *pool, health_check_port_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_stream_send(njt_pool_t *pool, health_check_stream_send_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_stream_expect(njt_pool_t *pool, health_check_stream_expect_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_stream(njt_pool_t *pool, health_check_stream_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_send_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->send.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"send\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream_send(pool, (&out->send), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_expect_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->expect.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"expect\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream_expect(pool, (&out->expect), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check_http_uri(njt_pool_t *pool, health_check_http_uri_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http_grpcService(njt_pool_t *pool, health_check_http_grpcService_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http_grpcStatus(njt_pool_t *pool, health_check_http_grpcStatus_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http_header_item(njt_pool_t *pool, health_check_http_header_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http_header(njt_pool_t *pool, health_check_http_header_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        omit = ((flags & OMIT_NULL_STR) && (&((health_check_http_header_item_t*)out->elts)[i])->data == NULL) ? 1 : 0;
        if (omit == 0) {
            to_oneline_json_health_check_http_header_item(pool, (&((health_check_http_header_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_health_check_http_body(njt_pool_t *pool, health_check_http_body_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http_status(njt_pool_t *pool, health_check_http_status_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_http(njt_pool_t *pool, health_check_http_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_uri_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->uri.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"uri\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_uri(pool, (&out->uri), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_grpcService_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->grpcService.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"grpcService\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_grpcService(pool, (&out->grpcService), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_grpcStatus_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"grpcStatus\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_grpcStatus(pool, (&out->grpcStatus), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_header_set ? 0 : 1;
    omit = (flags & OMIT_NULL_ARRAY) && (out->header) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"header\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_header(pool, (out->header), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_body_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->body.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"body\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_body(pool, (&out->body), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_status_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->status.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"status\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_status(pool, (&out->status), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check_ssl_enable(njt_pool_t *pool, health_check_ssl_enable_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_ntls(njt_pool_t *pool, health_check_ssl_ntls_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_session_reuse(njt_pool_t *pool, health_check_ssl_session_reuse_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_name(njt_pool_t *pool, health_check_ssl_name_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_protocols(njt_pool_t *pool, health_check_ssl_protocols_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_serverName(njt_pool_t *pool, health_check_ssl_serverName_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_verify(njt_pool_t *pool, health_check_ssl_verify_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_verifyDepth(njt_pool_t *pool, health_check_ssl_verifyDepth_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%L", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_trustedCertificate(njt_pool_t *pool, health_check_ssl_trustedCertificate_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_crl(njt_pool_t *pool, health_check_ssl_crl_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_certificate(njt_pool_t *pool, health_check_ssl_certificate_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_certificateKey(njt_pool_t *pool, health_check_ssl_certificateKey_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_encCertificate(njt_pool_t *pool, health_check_ssl_encCertificate_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_encCertificateKey(njt_pool_t *pool, health_check_ssl_encCertificateKey_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_passwords(njt_pool_t *pool, health_check_ssl_passwords_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_conf_commands(njt_pool_t *pool, health_check_ssl_conf_commands_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl_ciphers(njt_pool_t *pool, health_check_ssl_ciphers_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_ssl(njt_pool_t *pool, health_check_ssl_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_enable_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"enable\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_enable(pool, (&out->enable), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_ntls_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ntls\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_ntls(pool, (&out->ntls), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_session_reuse_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"session_reuse\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_session_reuse(pool, (&out->session_reuse), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_name_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->name.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"name\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_name(pool, (&out->name), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_protocols_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->protocols.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"protocols\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_protocols(pool, (&out->protocols), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_serverName_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"serverName\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_serverName(pool, (&out->serverName), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_verify_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"verify\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_verify(pool, (&out->verify), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_verifyDepth_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"verifyDepth\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_verifyDepth(pool, (&out->verifyDepth), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_trustedCertificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->trustedCertificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"trustedCertificate\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_trustedCertificate(pool, (&out->trustedCertificate), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_crl_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->crl.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"crl\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_crl(pool, (&out->crl), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_certificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->certificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"certificate\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_certificate(pool, (&out->certificate), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_certificateKey_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->certificateKey.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"certificateKey\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_certificateKey(pool, (&out->certificateKey), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_encCertificate_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->encCertificate.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"encCertificate\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_encCertificate(pool, (&out->encCertificate), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_encCertificateKey_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->encCertificateKey.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"encCertificateKey\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_encCertificateKey(pool, (&out->encCertificateKey), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_passwords_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->passwords.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"passwords\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_passwords(pool, (&out->passwords), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_conf_commands_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->conf_commands.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"conf_commands\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_conf_commands(pool, (&out->conf_commands), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_ciphers_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->ciphers.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ciphers\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_ciphers(pool, (&out->ciphers), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check(njt_pool_t *pool, health_check_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    omit = out->is_interval_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->interval.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"interval\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_interval(pool, (&out->interval), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_jitter_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->jitter.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"jitter\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_jitter(pool, (&out->jitter), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_timeout_set ? 0 : 1;
    omit = (flags & OMIT_NULL_STR) && (out->timeout.data) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"timeout\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_timeout(pool, (&out->timeout), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_passes_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"passes\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_passes(pool, (&out->passes), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_fails_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"fails\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_fails(pool, (&out->fails), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_port_set ? 0 : 1;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"port\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_port(pool, (&out->port), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_stream_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->stream) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"stream\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream(pool, (out->stream), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_http_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->http) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"http\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http(pool, (out->http), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    omit = out->is_ssl_set ? 0 : 1;
    omit = (flags & OMIT_NULL_OBJ) && (out->ssl) == NULL ? 1 : omit;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ssl\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl(pool, (out->ssl), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
health_check_t* json_parse_health_check(njt_pool_t *pool, const njt_str_t *json_string, js2c_parse_error_t *err_ret) {
    health_check_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_pcalloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_ret);
        if (parse_result == JSMN_ERROR_INVAL) {
            LOG_ERROR_JSON_PARSE(INVALID_JSON_CHAR_ERR, "", -1, "%s", "Invalid character inside JSON string");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_PART) {
            LOG_ERROR_JSON_PARSE(PARTIAL_JSON_ERR, "", -1, "%s", "The string is not a full JSON packet, more bytes expected");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(NULL_JSON_ERR, "", 0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_pcalloc(pool, sizeof(health_check_t));;
    memset(out, 0, sizeof(health_check_t));
    if (parse_health_check(pool, parse_state, out, err_ret)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_health_check(njt_pool_t *pool, health_check_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_pcalloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_health_check(pool, out, &str_len, flags);
    json_str->data = (u_char*)njt_pcalloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_health_check(pool, out, json_str, flags);
    return json_str;
}
